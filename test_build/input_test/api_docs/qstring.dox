/*************************************************************************
*
* Copyright (C) 2012-2017 Barbara Geller & Ansel Sermersheim
* Copyright (C) 2014 Digia Plc 
* All rights reserved.
*
* GNU Free Documentation License
*
*************************************************************************/

/*!
\class QString 
\brief The QString class provides a Unicode character string. 

The QString class provides a Unicode character string.

QString stores a string of 16-bit QChars, where each QChar corresponds one Unicode 4.0 character. (Unicode characters with code values above 65535 
are stored using surrogate pairs, i.e., two consecutive QChars.)

Unicode is an international standard that supports most of the writing systems in use today. It is a superset of US-ASCII (ANSI X3.4-1986) and 
Latin-1 (ISO 8859-1), and all the US-ASCII/Latin-1 characters are available at the same code positions.

Behind the scenes, QString uses implicit sharing (copy-on-write) to reduce memory usage and to avoid the needless copying of data. This also helps
reduce the inherent overhead of storing 16-bit characters instead of 8-bit characters.

In addition to QString, CS also provides the QByteArray class to store raw bytes and traditional 8-bit '\0'-terminated strings. For most purposes, QString is the class you want to use. It is used throughout the Qt API, and the Unicode support ensures that your applications will be easy to translate if you want to expand your application's market at some point. The two main cases where QByteArray is appropriate are when you need to store raw binary data, and when memory conservation is critical.


<h3>Initializing a String</h3>

One way to initialize a QString is simply to pass a <tt>const char *</tt> to its constructor. For example, the following code creates a QString of size 5 containing the data &quot;Hello&quot;:

\code
    QString str = "Hello";
\endcode

QString converts the <tt>const char *</tt> data into Unicode using the fromAscii() function. By default, fromAscii() treats character above 128 as
Latin-1 characters, but this can be changed by calling QTextCodec::setCodecForCStrings().

In all of the QString functions that take <tt>const char *</tt> parameters, the <tt>const char *</tt> is interpreted as a classic C-style '\0'-terminated 
string. It is legal for the <tt>const char *</tt> parameter to be 0.

You can also provide string data as an array of QChars:

\code
    static const QChar data[4] = { 0x0055, 0x006e, 0x10e3, 0x03a3 };
    QString str(data, 4);
\endcode

QString makes a deep copy of the QChar data, so you can modify it later without experiencing side effects. (If for performance reasons you
do not want to take a deep copy of the character data, use QString::fromRawData() instead.)

Another approach is to set the size of the string using resize() and to initialize the data character per character. QString uses 0-based
indexes, just  like C++ arrays. To access the character at a particular index position, you can use operator[](). On non-const strings, 
operator[]() returns a reference to a character that can be used on the left side of an assignment. For example:

\code
    QString str;
    str.resize(4);

    str[0] = QChar('U');
    str[1] = QChar('n');
    str[2] = QChar(0x10e3);
    str[3] = QChar(0x03a3);
\endcode

For read-only access, an alternative syntax is to use the at() function:

\code
    QString str;

    for (int i = 0; i < str.size(); ++i) {
        if (str.at(i) >= QChar('a') && str.at(i) <= QChar('f')) {
            qDebug() << "Found character in range [a-f]";
        }
    }
\endcode

The at() function can be faster than operator[](), because it never causes a deep copy to occur. Alternatively, use the left(), right(), or mid()
functions to extract several characters at a time.

A QString can embed '\0' characters (QChar::Null). The size() function always returns the size of the whole string, including embedded '\0' characters.

After a call to the resize() function, newly allocated characters have undefined values. To set all the characters in the string to a particular value, 
use the fill() function.

QString provides dozens of overloads designed to simplify string usage. For example, if you want to compare a QString with a string literal, you can
write code like this and it will work as expected:

\code
    QString str;

    if (str == "auto" || str == "extern" || str == "static" || str == "register") {
        // ...
    }
\endcode

You can also pass string literals to functions that take QStrings as arguments, invoking the QString(const char *) constructor. Similarly,
you can pass a QString to a function that takes a <tt>const char *</tt> argument using the qPrintable() macro which returns the given
QString as a <tt>const char *</tt>. This is equivalent to calling &lt;QString&gt;.toLocal8Bit().constData().


<h3>Manipulating String Data</h3>

QString provides the following basic functions for modifying the character data: append(), prepend(), insert(), replace(), and remove(). For example:

\code
    QString str = "and";
    str.prepend("rock ");         // str == "rock and"
    str.append(" roll");          // str == "rock and roll"
    str.replace(5, 3, "&");       // str == "rock &roll"
\endcode

If you are building a QString gradually and know in advance approximately how many characters the QString will contain, you can call reserve(), asking QString to preallocate a certain amount of memory. You can also call capacity() to find out how much memory QString actually allocated.

The replace() and remove() functions' first two arguments are the position from which to start erasing and the number of characters that should be erased. If you want to replace all occurrences of a particular substring with another, use one of the two-parameter replace() overloads.

A frequent requirement is to remove whitespace characters from a string ('\\n', '\\t', ' ', etc.). If you want to remove whitespace from both ends of a QString, use the trimmed() function. If you want to remove whitespace from both ends and replace multiple consecutive whitespaces with a single space character within the string, use simplified().

If you want to find all occurrences of a particular character or substring in a QString, use the indexOf() or lastIndexOf() functions. The former searches forward starting from a given index position, the latter searches backward. Both return the index position of the character or substring if they find it; otherwise, they return -1. For example, here's a typical loop that finds all occurrences of a particular substring:

\code
    QString str = "We must be <b>bold</b>, very <b>bold</b>";
    int j = 0;

    while ((j = str.indexOf("<b>", j)) != -1) {
        qDebug() << "Found <b> tag at index position" << j;
        ++j;
    }
\endcode

QString provides many functions for converting numbers into strings and strings into numbers. See the arg() functions, the setNum() functions, the number() static functions, and the toInt(), toDouble(), and similar functions.

To get an upper- or lowercase version of a string use toUpper() or toLower().

Lists of strings are handled by the QStringList class. You can split a string into a list of strings using the split() function, and join a list of strings into a single string with an optional separator using QStringList::join(). You can obtain a list of strings from a string list that contain a particular substring or that match a particular QRegExp using the QStringList::filter() function.


<h3>Querying String Data</h3>

If you want to see if a QString starts or ends with a particular substring use startsWith() or endsWith(). If you simply want to check whether a QString contains a particular character or substring, use the contains() function. If you want to find out how many times a particular character or substring occurs in the string, use count().

QStrings can be compared using overloaded operators such as operator<(), operator<=(), operator==(), operator>=(), and so on. Note that the comparison is based exclusively on the numeric Unicode values of the characters. It is very fast, but is not what a human would expect; the QString::localeAwareCompare() function is a better choice for sorting user-interface strings.

To obtain a pointer to the actual character data, call data() or constData(). These functions return a pointer to the beginning of the QChar data. The pointer is guaranteed to remain valid until a non-const function is called on the QString.


<h3>Converting Between 8-Bit Strings and Unicode Strings</h3>

QString provides the following four functions that return a <tt>const char *</tt> version of the string as QByteArray: toAscii(), toLatin1(), toUtf8(), and toLocal8Bit().

<ul>
   <li>toAscii() returns an 8-bit string encoded using the codec specified by QTextCodec::codecForCStrings (by default, that
       is Latin 1).</li>
   <li>toLatin1() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.</li>
   <li>toUtf8() returns a UTF-8 encoded 8-bit string. UTF-8 is a superset of US-ASCII (ANSI X3.4-1986) that supports the entire 
       Unicode character set through multibyte sequences.</li>
   <li>toLocal8Bit() returns an 8-bit string using the system's local encoding.</li>
</ul>

To convert from one of these encodings, QString provides fromAscii(), fromLatin1(), fromUtf8(), and fromLocal8Bit(). Other encodings are supported through the QTextCodec class.

As mentioned above, QString provides a lot of functions and operators that make it easy to interoperate with <tt>const char *</tt> strings. But this functionality is a double-edged sword: It makes QString more convenient to use if all strings are US-ASCII or Latin-1, but there is always the risk that an implicit conversion from or to <tt>const char *</tt> is done using the wrong 8-bit encoding. To minimize these risks, you can turn off these implicit conversions by defining the following two preprocessor symbols:

<ul>
   <li><tt>QT_NO_CAST_FROM_ASCII</tt> disables automatic conversions from C string literals and pointers to Unicode.</li>
   <li><tt>QT_NO_CAST_TO_ASCII</tt> disables automatic conversion from QString to C strings.</li>
</ul>

You then need to explicitly call fromAscii(), fromLatin1(), fromUtf8(), or fromLocal8Bit() to construct a QString from an 8-bit string, or use the lightweight QLatin1String class, for example:

\code
    QString url = QLatin1String("http://www.unicode.org/");
\endcode

Similarly, you must call toAscii(), toLatin1(), toUtf8(), or toLocal8Bit() explicitly to convert the QString to an 8-bit string. 
(Other encodings are supported through the QTextCodec class.)



<h3>Distinction Between Null and Empty Strings</h3>

For historical reasons, QString distinguishes between a null string and an empty string. A <i>null</i> string is a string that is initialized
using QString's default constructor or by passing (const char *)0 to the constructor. An <i>empty</i> string is any string with size 0. A
null string is always empty, but an empty string is not necessarily null:

\code
    QString().isNull();               // returns true
    QString().isEmpty();              // returns true

    QString("").isNull();             // returns false
    QString("").isEmpty();            // returns true

    QString("abc").isNull();          // returns false
    QString("abc").isEmpty();         // returns false
\endcode

All functions except isNull() treat null strings the same as empty strings. For example, toAscii().constData() returns a pointer to a '\0' character for a null string (<i>not</i> a null pointer), and QString() compares equal to QString(&quot;&quot;). We recommend that you always use the isEmpty() function and avoid isNull().


<h3>Argument Formats</h3>

In member functions where an argument <i>format</i> can be specified (e.g., arg(), number()), the argument <i>format</i> can be one of the following:

A <i>precision</i> is also specified with the argument <i>format</i>. For the 'e', 'E', and 'f' formats, the <i>precision</i> represents the number of digits <i>after</i> the decimal point. For the 'g' and 'G' formats, the <i>precision</i> represents the maximum number of significant digits (trailing zeroes are omitted).


<h3>More Efficient String Construction</h3>

Using the QString <tt>'+'</tt> operator, it is easy to construct a complex string from multiple substrings. You will often write code like this:

\code
   QString foo;
   QString type = "long";

   foo->setText(QLatin1String("vector<") + type + QLatin1String(">::iterator"));

   if (foo.startsWith("(" + type + ") 0x"))
      ...
\endcode

There is nothing wrong with either of these string constructions, but there are a few hidden inefficiencies. Beginning with Qt 4.6, you can eliminate them.

First, multiple uses of the <tt>'+'</tt> operator usually means multiple memory allocations. When concatenating <i>n</i> substrings, where 
<i>n &gt; 2</i>, there can be as many as <i>n - 1</i> calls to the memory allocator.

Second, QLatin1String does not store its length internally but calls qstrlen() when it needs to know its length.

In 4.6, an internal template class <tt>QStringBuilder</tt> has been added along with a few helper functions. This class is marked internal and does not appear in the documentation, because you aren't meant to instantiate it in your code. Its use will be automatic, as described below. The class is found in <tt>src/corelib/tools/qstringbuilder.cpp</tt> if you want to have a look at it.

<tt>QStringBuilder</tt> uses expression templates and reimplements the <tt>'%'</tt> operator so that when you use <tt>'%'</tt> for string concatenation instead of <tt>'+'</tt>, multiple substring concatenations will be postponed until the final result is about to be assigned to a QString. At this point, the amount of memory required for the final result is known. The memory allocator is then called <i>once</i> to get the required space, and the substrings are copied into it one by one.

<tt>QLatin1Literal</tt> is a second internal class that can replace QLatin1String, which can't be changed for compatibility reasons. <tt>QLatin1Literal</tt> stores its length, thereby saving time when <tt>QStringBuilder</tt> computes the amount of memory required for the final string.

Additional efficiency is gained by inlining and reduced reference counting (the QString created from a <tt>QStringBuilder</tt> typically has a ref count of 1, whereas QString::append() needs an extra test).

There are three ways you can access this improved method of string construction. The straightforward way is to include <tt>QStringBuilder</tt> wherever you want to use it, and use the <tt>'%'</tt> operator instead of <tt>'+'</tt> when concatenating strings:

\code
        #include <QStringBuilder>

        QString hello("hello");
        QStringRef el(&hello, 2, 3);

        QLatin1String world("world");
        QString message =  hello % el % world % QChar('!');
\endcode

<b>See also </b>fromRawData(), QChar, QLatin1String, QByteArray, and QStringRef.
*/


/*!
\fn QString::QString ()

Constructs a null string. Null strings are also empty.

<b>See also </b>isEmpty().

*/


/*!
\fn QString::QString ( const QChar * unicode, int size )

Constructs a string initialized with the characters of the QChar array <i>unicode</i>, which must be terminated with a 0.

QString makes a deep copy of the string data. The unicode data is copied as is and the Byte Order Mark is preserved if present.

*/


/*!
\fn QString::QString ( QChar ch )

Constructs a string of size 1 containing the character <i>ch</i>.


<h3>Auto Linking / Testing</h3>

The following documentation is here for the purpose of testing links to another class. 

First one is a link, the second one is not: 

   \li MySpace::AlignmentFlag

   \li AlignmentFlag

First one is a link, the second one is not: 

   \li MySpace::mightBeRichText()

   \li mightBeRichText()


*/


/*!
\fn QString::QString ( int size, QChar ch )

Constructs a string of the given <i>size</i> with every character set to <i>ch</i>.

<b>See also </b>fill().

*/


/*!
\fn QString::QString ( const QLatin1String & str )

Constructs a copy of the Latin-1 string <i>str</i>.

<b>See also </b>fromLatin1().

*/


/*!
\fn QString::QString ( const QString & other )

Constructs a copy of <i>other</i>.

This operation takes constant time, because QString is implicitly shared. This makes returning a QString from a function very fast. If a shared instance is modified, it will be copied (copy-on-write), and that takes linear time.

<b>See also </b>operator=().

*/


/*!
\fn QString::QString ( const char * str )

Constructs a string initialized with the 8-bit string <i>str</i>. The given const char pointer is converted to Unicode using the fromAscii() function.

You can disable this constructor by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.

<b>See also </b>fromAscii(), fromLatin1(), fromLocal8Bit(), and fromUtf8().


*/


/*!
\fn QString::QString ( const QByteArray & ba )

Constructs a string initialized with the byte array <i>ba</i>. The given byte array is converted to Unicode using fromAscii(). Stops copying at the first 0 character, otherwise copies the entire byte array.

You can disable this constructor by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.

<b>See also </b>fromAscii(), fromLatin1(), fromLocal8Bit(), and fromUtf8().


*/


/*!
\fn QString::~QString ()

Destroys the string.


*/


/*!
\fn QString & QString::append ( const QString & str )

Appends the string <i>str</i> onto the end of this string.

Example:

\code
    QString x = "free";
    QString y = "dom";

    x.append(y);
    // x == "freedom"
\endcode

This is the same as using the insert() function:

\code
    x.insert(x.size(), y);
\endcode

The append() function is typically very fast (constant time), because QString preallocates extra space at the end of the string data so it can grow
without reallocating the entire string each time.

<b>See also </b>operator+=(), prepend(), and insert().


*/


/*!
\fn QString & QString::append ( const QStringRef & reference )

Appends the given string <i>reference</i> to this string and returns the result.

*/


/*!
\fn QString & QString::append ( const QLatin1String & str )

This function overloads append().

Appends the Latin-1 string <i>str</i> to this string.


*/


/*!
\fn QString & QString::append ( const QByteArray & ba ) 

This function overloads append().

Appends the byte array <i>ba</i> to this string. The given byte array is converted to Unicode using the fromAscii() function.

You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::append ( const char * str )

This function overloads append().

Appends the string <i>str</i> to this string. The given const char pointer is converted to Unicode using the fromAscii() function.

You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::append ( QChar ch )

This function overloads append().

Appends the character <i>ch</i> to this string.


*/


/*!
\fn QString QString::arg ( const QString & a, int fieldWidth = 0, QChar fillChar = QLatin1Char( ' ' ) ) const

Returns a copy of this string with the lowest numbered place marker replaced by string <i>a</i>, i.e., <tt>%1</tt>, <tt>%2</tt>, ..., <tt>%99</tt>.

<i>fieldWidth</i> specifies the minimum amount of space that argument <i>a</i> shall occupy. If <i>a</i> requires less space than <i>fieldWidth</i>, it is padded to <i>fieldWidth</i> with character <i>fillChar</i>. A positive <i>fieldWidth</i> produces right-aligned text. A negative <i>fieldWidth</i> produces left-aligned text.

This example shows how we might create a <tt>status</tt> string for reporting progress while processing a list of files:

\code
    QString i;           // current file's number
    QString total;       // number of files to process
    QString fileName;    // current file's name

    QString status = QString("Processing file %1 of %2: %3")
                    .arg(i).arg(total).arg(fileName);
\endcode

First, <tt>arg(i)</tt> replaces <tt>%1</tt>. Then <tt>arg(total)</tt> replaces <tt>%2</tt>. Finally, <tt>arg(fileName)</tt> replaces <tt>%3</tt>.

One advantage of using arg() over sprintf() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest numbered unreplaced place marker, no matter where it appears. Also, if place marker <tt>%i</tt> appears more than once in the string, the arg() replaces all of them.

If there is no unreplaced place marker remaining, a warning message is output and the result is undefined. Place marker numbers must be in the range 1 to 99.


*/


/*!
\fn QString QString::arg ( const QString & a1, const QString & a2 ) const

This function overloads arg().

This is the same as <tt>str.arg(a1).arg(a2)</tt>, except that the strings <i>a1</i> and <i>a2</i> are replaced in one pass. This can make a difference if <i>a1</i> contains e.g. <tt>%1</tt>:

\code
    QString str;
    str = "%1 %2";

    str.arg("%1f", "Hello");        // returns "%1f Hello"
    str.arg("%1f").arg("Hello");    // returns "Hellof %2"
\endcode


*/


/*!
\fn QString QString::arg ( const QString & a1, const QString & a2, const QString & a3 ) const

This function overloads arg().

This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3)</tt>, except that the strings <i>a1</i>, <i>a2</i> and <i>a3</i> are replaced in one pass.


*/


/*!
\fn QString QString::arg ( const QString & a1, const QString & a2, const QString & a3, const QString & a4 ) const

This function overloads arg().

This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i> and <i>a4</i> are replaced in one pass.


*/


/*!
\fn QString QString::arg ( const QString & a1, const QString & a2, const QString & a3, const QString & a4, const QString & a5 ) const

This function overloads arg().

This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, and <i>a5</i> are replaced in one pass.


*/


/*!
\fn QString QString::arg ( const QString & a1, const QString & a2, const QString & a3, const QString & a4, const QString & a5, const QString & a6 ) const

This function overloads arg().

This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, and <i>a6</i> are replaced in one pass.


*/


/*!
\fn QString QString::arg ( const QString & a1, const QString & a2, const QString & a3, const QString & a4, const QString & a5, const QString & a6, const QString & a7 ) const

This function overloads arg().

This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, <i>a6</i>, and <i>a7</i> are replaced in one pass.


*/


/*!
\fn QString QString::arg ( const QString & a1, const QString & a2, const QString & a3, const QString & a4, const QString & a5, const QString & a6, const QString & a7, const QString & a8 ) const

This function overloads arg().

This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, <i>a6</i>, <i>a7</i>, and <i>a8</i> are replaced in one pass.


*/


/*!
\fn QString QString::arg ( const QString & a1, const QString & a2, const QString & a3, const QString & a4, const QString & a5, const QString & a6, const QString & a7, const QString & a8, const QString & a9 ) const

This function overloads arg().

This is the same as calling <tt>str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)</tt>, except that the strings <i>a1</i>, <i>a2</i>, <i>a3</i>, <i>a4</i>, <i>a5</i>, <i>a6</i>, <i>a7</i>, <i>a8</i>, and <i>a9</i> are replaced in one pass.


*/


/*!
\fn QString QString::arg ( int a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

The <i>a</i> argument is expressed in base <i>base</i>, which is 10 by default and must be between 2 and 36. For bases other than 10, <i>a</i> is treated as an unsigned integer.

<i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.

The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i>a</i>. The conversion uses the default locale, set by QLocale::setDefault(). If no default locale was specified, the &quot;C&quot; locale is used. The 'L' flag is ignored if <i>base</i> is not 10.

\code
    QString str;
    str = QString("Decimal 63 is %1 in hexadecimal").arg(63, 0, 16);
    // str == "Decimal 63 is 3f in hexadecimal"

    QLocale::setDefault(QLocale(QLocale::English, QLocale::UnitedStates));
    str = QString("%1 %L2 %L3").arg(12345).arg(12345).arg(12345, 0, 16);
    // str == "12345 12,345 3039"
\endcode

If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.


*/


/*!
\fn QString QString::arg ( uint a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36.

If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.


*/


/*!
\fn QString QString::arg ( long a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

<i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.

The <i>a</i> argument is expressed in the given <i>base</i>, which is 10 by default and must be between 2 and 36.

The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i>a</i>. The conversion uses the default locale. The default locale is determined from the system's locale settings at application startup. It can be changed using QLocale::setDefault(). The 'L' flag is ignored if <i>base</i> is not 10.

\code
    QString str;
    str = QString("Decimal 63 is %1 in hexadecimal").arg(63, 0, 16);
    // str == "Decimal 63 is 3f in hexadecimal"

    QLocale::setDefault(QLocale(QLocale::English, QLocale::UnitedStates));
    str = QString("%1 %L2 %L3").arg(12345).arg(12345).arg(12345, 0, 16);
    // str == "12345 12,345 3039"
\endcode

If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.


*/


/*!
\fn QString QString::arg ( ulong a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

<i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.

The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> to a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.

If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.


*/


/*!
\fn QString QString::arg ( qlonglong a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

<i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.

The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.

If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.


*/


/*!
\fn QString QString::arg ( qulonglong a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

<i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.

The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. <i>base</i> must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.

If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.


*/


/*!
\fn QString QString::arg ( short a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

<i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.

The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.

If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.


*/


/*!
\fn QString QString::arg ( ushort a, int fieldWidth = 0, int base = 10, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

<i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.

The <i>base</i> argument specifies the base to use when converting the integer <i>a</i> into a string. The base must be between 2 and 36, with 8 giving octal, 10 decimal, and 16 hexadecimal numbers.

If <i>fillChar</i> is '0' (the number 0, ASCII 48), the locale's zero is used. For negative numbers, zero padding might appear before the minus sign.


*/


/*!
\fn QString QString::arg ( QChar a, int fieldWidth = 0, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().


*/


/*!
\fn QString QString::arg ( char a, int fieldWidth = 0, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

The <i>a</i> argument is interpreted as a Latin-1 character.


*/


/*!
\fn QString QString::arg ( double a, int fieldWidth = 0, char format = 'g', int precision = -1, QChar fillChar = QLatin1Char( ' ' ) ) const

This function overloads arg().

Argument <i>a</i> is formatted according to the specified <i>format</i> and <i>precision</i>. See Argument Formats for details.

<i>fieldWidth</i> specifies the minimum amount of space that <i>a</i> is padded to and filled with the character <i>fillChar</i>. A positive value produces right-aligned text; a negative value produces left-aligned text.

\code
    double d = 12.34;
    QString str = QString("delta: %1").arg(d, 0, 'E', 3);
    // str == "delta: 1.234E+01"
\endcode

The '%' can be followed by an 'L', in which case the sequence is replaced with a localized representation of <i>a</i>. The conversion uses the default locale, set by QLocale::setDefaultLocale(). If no default locale was specified, the &quot;C&quot; locale is used.

If <i>fillChar</i> is '0' (the number 0, ASCII 48), this function will use the locale's zero to pad. For negative numbers, the zero padding will probably appear before the minus sign.

<b>See also </b>QLocale::toString().


*/


/*!
\fn const QChar QString::at ( int position ) const

Returns the character at the given index <i>position</i> in the string.

The <i>position</i> must be a valid index position in the string (i.e., 0 &lt;= <i>position</i> &lt; size()).

<b>See also </b>operator[]().


*/


/*!
\fn iterator QString::begin ()

Returns an STL-style iterator pointing to the first character in the string.

<b>See also </b>constBegin() and end().


*/


/*!
\fn const_iterator QString::begin () const

This function overloads begin().


*/


/*!
\fn int QString::capacity () const

Returns the maximum number of characters that can be stored in the string without forcing a reallocation.

The sole purpose of this function is to provide a means of fine tuning QString's memory usage. In general, you will rarely ever need to call this function. If you want to know how many characters are in the string, call size().

<b>See also </b>reserve() and squeeze().


*/


/*!
\fn void QString::chop ( int n )

Removes <i>n</i> characters from the end of the string.

If <i>n</i> is greater than size(), the result is an empty string.

Example:

\code
    QString str("LOGOUT\r\n");
    str.chop(2);
    // str == "LOGOUT"
\endcode

If you want to remove characters from the <i>beginning</i> of the string, use remove() instead.

<b>See also </b>truncate(), resize(), and remove().


*/


/*!
\fn void QString::clear ()

Clears the contents of the string and makes it empty.

<b>See also </b>resize() and isEmpty().


*/


/*!
\fn int QString::compare ( const QString & s1, const QString & s2, Qt::CaseSensitivity cs ) [static]

Compares <i>s1</i> with <i>s2</i> and returns an integer less than, equal to, or greater than zero if <i>s1</i> is less than, equal to, or greater than <i>s2</i>.

If <i>cs</i> is Qt::CaseSensitive, the comparison is case sensitive; otherwise the comparison is case insensitive.

Case sensitive comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-visible strings with localeAwareCompare().

\code
    int x = QString::compare("aUtO", "AuTo", Qt::CaseInsensitive);  // x == 0
    int y = QString::compare("auto", "Car",  Qt::CaseSensitive);     // y > 0
    int z = QString::compare("auto", "Car",  Qt::CaseInsensitive);   // z < 0
\endcode

<b>See also </b>operator==(), operator&lt;(), and operator&gt;().


*/


/*!
\fn int QString::compare ( const QString & s1, const QString & s2 ) [static]

This function overloads compare().

Performs a case sensitive compare of <i>s1</i> and <i>s2</i>.


*/


/*!
\fn int QString::compare ( const QString & s1, const QLatin1String & s2, Qt::CaseSensitivity cs = Qt::CaseSensitive ) [static]

This function overloads compare().

Performs a comparison of <i>s1</i> and <i>s2</i>, using the case sensitivity setting <i>cs</i>.

*/


/*!
\fn int QString::compare ( const QLatin1String & s1, const QString & s2, Qt::CaseSensitivity cs = Qt::CaseSensitive ) [static]

This function overloads compare().

Performs a comparison of <i>s1</i> and <i>s2</i>, using the case sensitivity setting <i>cs</i>.

*/


/*!
\fn int QString::compare ( const QString & other ) const

This function overloads compare().

Lexically compares this string with the <i>other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the other string.

Equivalent to <tt>compare(*this, other)</tt>.


*/


/*!
\fn int QString::compare ( const QString & other, Qt::CaseSensitivity cs ) const

This function overloads compare().

Same as compare(*this, <i>other</i>, <i>cs</i>).

*/


/*!
\fn int QString::compare ( const QLatin1String & other, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads compare().

Same as compare(*this, <i>other</i>, <i>cs</i>).

*/


/*!
\fn int QString::compare ( const QStringRef & ref, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads compare().

Compares the string reference, <i>ref</i>, with the string and returns an integer less than, equal to, or greater than zero if the string is less than, equal to, or greater than <i>ref</i>.


*/


/*!
\fn int QString::compare ( const QString & s1, const QStringRef & s2, Qt::CaseSensitivity cs = Qt::CaseSensitive ) [static]

This function overloads compare().


*/


/*!
\fn const_iterator QString::constBegin () const

Returns a const STL-style iterator pointing to the first character in the string.

<b>See also </b>begin() and constEnd().


*/


/*!
\fn const QChar * QString::constData () const

Returns a pointer to the data stored in the QString. The pointer can be used to access the characters that compose the string. For convenience, 
the data is '\0'-terminated.

Note that the pointer remains valid only as long as the string is not modified.

<b>See also </b>data() and operator[]().


*/


/*!
\fn const_iterator QString::constEnd () const

Returns a const STL-style iterator pointing to the imaginary item after the last item in the list.

<b>See also </b>constBegin() and end().


*/


/*!
\fn QBool QString::contains ( const QString & str, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Returns true if this string contains an occurrence of the string <i>str</i>; otherwise returns false.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

Example:

\code
    QString str = "Peter Pan";
    str.contains("peter", Qt::CaseInsensitive);    // returns true
\endcode

<b>See also </b>indexOf() and count().


*/


/*!
\fn QBool QString::contains ( const QStringRef & str, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Returns true if this string contains an occurrence of the string reference <i>str</i>; otherwise returns false.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>See also </b>indexOf() and count().


*/


/*!
\fn QBool QString::contains ( QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads contains().

Returns true if this string contains an occurrence of the character <i>ch</i>; otherwise returns false.


*/


/*!
\fn QBool QString::contains ( const QRegExp & rx ) const

This function overloads contains().

Returns true if the regular expression <i>rx</i> matches somewhere in this string; otherwise returns false.


*/


/*!
\fn QBool QString::contains ( QRegExp & rx ) const

This function overloads contains().

Returns true if the regular expression <i>rx</i> matches somewhere in this string; otherwise returns false.

If there is a match, the <i>rx</i> regular expression will contain the matched captures (see QRegExp::matchedLength, QRegExp::cap).

*/


/*!
\fn int QString::count ( const QString & str, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Returns the number of (potentially overlapping) occurrences of the string <i>str</i> in this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>See also </b>contains() and indexOf().


*/


/*!
\fn int QString::count ( QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads count().

Returns the number of occurrences of character <i>ch</i> in the string.


*/


/*!
\fn int QString::count ( const QStringRef & str, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads count().

Returns the number of (potentially overlapping) occurrences of the string reference <i>str</i> in this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>See also </b>contains() and indexOf().


*/


/*!
\fn int QString::count ( const QRegExp & rx ) const

This function overloads count().

Returns the number of times the regular expression <i>rx</i> matches in the string.

This function counts overlapping matches, so in the example below, there are four instances of &quot;ana&quot; or &quot;ama&quot;:

\code
    QString str = "banana and panama";
    str.count(QRegExp("a[nm]a"));    // returns 4
\endcode


*/


/*!
\fn int QString::count () const

This function overloads count().

Same as size().


*/


/*!
\fn QChar * QString::data ()

Returns a pointer to the data stored in the QString. The pointer can be used to access and modify the characters that compose the string. For convenience,
the data is '\0'-terminated.

Example:

\code
    QString str = "Hello world";
    QChar *data = str.data();

    while (!data->isNull()) {
        qDebug() << data->unicode();
        ++data;
    }
\endcode

Note that the pointer remains valid only as long as the string is not modified by other means. For read-only access, constData() is faster because it never
causes a deep copy to occur.

<b>See also </b>constData() and operator[]().

*/


/*!
\fn const QChar * QString::data () const

This is an overloaded function.


*/


/*!
\fn iterator QString::end ()

Returns an STL-style iterator pointing to the imaginary character after the last character in the string.

<b>See also </b>begin() and constEnd().


*/


/*!
\fn const_iterator QString::end () const

This function overloads end().


*/


/*!
\fn bool QString::endsWith ( const QString & s, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Returns true if the string ends with <i>s</i>; otherwise returns false.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

\code
    QString str = "Bananas";
    str.endsWith("anas");         // returns true
    str.endsWith("pple");         // returns false
\endcode

<b>See also </b>startsWith().


*/


/*!
\fn bool QString::endsWith ( const QStringRef & s, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads endsWith().

Returns true if the string ends with the string reference <i>s</i>; otherwise returns false.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>See also </b>startsWith().


*/


/*!
\fn bool QString::endsWith ( const QLatin1String & s, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads endsWith().


*/


/*!
\fn bool QString::endsWith ( QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Returns true if the string ends with <i>c</i>; otherwise returns false.

This function overloads endsWith().


*/


/*!
\fn QString & QString::fill ( QChar ch, int size = -1 )

Sets every character in the string to character <i>ch</i>. If <i>size</i> is different from -1 (default), the string is resized to <i>size</i> beforehand.

Example:

\code
    QString str = "Berlin";
    str.fill('z');
    // str == "zzzzzz"

    str.fill('A', 2);
    // str == "AA"
\endcode

<b>See also </b>resize().


*/


/*!
\fn QString QString::fromAscii ( const char * str, int size = -1 ) [static]

Returns a QString initialized with the first <i>size</i> characters from the string <i>str</i>.

If <i>size</i> is -1 (default), it is taken to be qstrlen(<i>str</i>).

Note that, despite the name, this function actually uses the codec defined by QTextCodec::setCodecForCStrings() to convert <i>str</i> to Unicode. Depending on the codec, it may not accept valid US-ASCII (ANSI X3.4-1986) input. If no codec has been set, this function does the same as fromLatin1().

<b>See also </b>toAscii(), fromLatin1(), fromUtf8(), and fromLocal8Bit().


*/


/*!
\fn QString QString::fromLatin1 ( const char * str, int size = -1 ) [static]

Returns a QString initialized with the first <i>size</i> characters of the Latin-1 string <i>str</i>.

If <i>size</i> is -1 (default), it is taken to be qstrlen(<i>str</i>).

<b>See also </b>toLatin1(), fromAscii(), fromUtf8(), and fromLocal8Bit().


*/


/*!
\fn QString QString::fromLocal8Bit ( const char * str, int size = -1 ) [static]

Returns a QString initialized with the first <i>size</i> characters of the 8-bit string <i>str</i>.

If <i>size</i> is -1 (default), it is taken to be qstrlen(<i>str</i>).

QTextCodec::codecForLocale() is used to perform the conversion.

<b>See also </b>toLocal8Bit(), fromAscii(), fromLatin1(), and fromUtf8().


*/


/*!
\fn QString QString::fromRawData ( const QChar * unicode, int size ) [static]

Constructs a QString that uses the first <i>size</i> Unicode characters in the array <i>unicode</i>. The data in <i>unicode</i> is <i>not</i> copied. The caller must be able to guarantee that <i>unicode</i> will not be deleted or modified as long as the QString (or an unmodified copy of it) exists.

Any attempts to modify the QString or copies of it will cause it to create a deep copy of the data, ensuring that the raw data isn't modified.

Here's an example of how we can use a QRegExp on raw data in memory without requiring to copy the data into a QString:

\code
    QRegExp pattern;
    static const QChar unicode[] = {
            0x005A, 0x007F, 0x00A4, 0x0060,
            0x1009, 0x0020, 0x0020};
    int size = sizeof(unicode) / sizeof(QChar);

    QString str = QString::fromRawData(unicode, size);
    if (str.contains(QRegExp(pattern))) {
        // ...
    }
\endcode

<b>Warning:</b> A string created with fromRawData() is <i>not</i> '\0'-terminated, unless the raw data contains a '\0' character at position <i>size</i>. This means unicode() will <i>not</i> return a '\0'-terminated string (although utf16() does, at the cost of copying the raw data).

<b>See also </b>fromUtf16() and setRawData().


*/


/*!
\fn QString QString::fromStdString ( const std::string & str ) [static]

Returns a copy of the <i>str</i> string. The given string is converted to Unicode using the fromAscii() function.

This constructor is only available if Qt is configured with STL compatibility enabled.

<b>See also </b>fromAscii(), fromLatin1(), fromLocal8Bit(), and fromUtf8().


*/


/*!
\fn QString QString::fromStdWString ( const std::wstring & str ) [static]

Returns a copy of the <i>str</i> string. The given string is assumed to be encoded in utf16 if the size of wchar_t is 2 bytes (e.g. on windows) and ucs4 if the size of wchar_t is 4 bytes (most Unix systems).

This method is only available if Qt is configured with STL compatibility enabled.

<b>See also </b>fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), and fromUcs4().


*/


/*!
\fn QString QString::fromUcs4 ( const uint * unicode, int size = -1 ) [static]

Returns a QString initialized with the first <i>size</i> characters of the Unicode string <i>unicode</i> (ISO-10646-UCS-4 encoded).

If <i>size</i> is -1 (default), <i>unicode</i> must be terminated with a 0.

<b>See also </b>toUcs4(), fromUtf16(), utf16(), setUtf16(), and fromWCharArray().


*/


/*!
\fn QString QString::fromUtf8 ( const char * str, int size = -1 ) [static]

Returns a QString initialized with the first <i>size</i> bytes of the UTF-8 string <i>str</i>.

If <i>size</i> is -1 (default), it is taken to be qstrlen(<i>str</i>).

UTF-8 is a Unicode codec and can represent all characters in a Unicode string like QString. However, invalid sequences are possible with UTF-8 and, if any such are found, they will be replaced with one or more &quot;replacement characters&quot;, or suppressed. These include non-Unicode sequences, non-characters, overlong sequences or surrogate codepoints encoded into UTF-8.

Non-characters are codepoints that the Unicode standard reserves and must not be used in text interchange. They are the last two codepoints in each Unicode Plane (U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, etc.), as well as 16 codepoints in the range U+FDD0..U+FDDF, inclusive.

<b>See also </b>toUtf8(), fromAscii(), fromLatin1(), and fromLocal8Bit().


*/


/*!
\fn QString QString::fromUtf16 ( const ushort * unicode, int size = -1 ) [static]

Returns a QString initialized with the first <i>size</i> characters of the Unicode string <i>unicode</i> (ISO-10646-UTF-16 encoded).

If <i>size</i> is -1 (default), <i>unicode</i> must be terminated with a 0.

This function checks for a Byte Order Mark (BOM). If it is missing, host byte order is assumed.

This function is slow compared to the other Unicode conversions. Use QString(const QChar *, int) or QString(const QChar *) if possible.

QString makes a deep copy of the Unicode data.

<b>See also </b>utf16() and setUtf16().


*/


/*!
\fn QString QString::fromWCharArray ( const wchar_t * string, int size = -1 ) [static]

Returns a copy of the <i>string</i>, where the encoding of <i>string</i> depends on the size of wchar. If wchar is 4 bytes, the <i>string</i> is
interpreted as ucs-4, if wchar is 2 bytes it is interpreted as ucs-2.

If <i>size</i> is -1 (default), the <i>string</i> has to be 0 terminated.

<b>See also </b>fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(), and fromStdWString().


*/


/*!
\fn int QString::indexOf ( const QString & str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Returns the index position of the first occurrence of the string <i>str</i> in this string, searching forward from index position <i>from</i>. 
Returns -1 if <i>str</i> is not found.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

Example:

\code
    QString x = "sticky question";
    QString y = "sti";
    x.indexOf(y);               // returns 0
    x.indexOf(y, 1);            // returns 10
    x.indexOf(y, 10);           // returns 10
    x.indexOf(y, 11);           // returns -1
\endcode

If <i>from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.

<b>See also </b>lastIndexOf(), contains(), and count().


*/


/*!
\fn int QString::indexOf ( const QLatin1String & str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Returns the index position of the first occurrence of the string <i>str</i> in this string, searching forward from index position <i>from</i>. 
Returns -1 if <i>str</i> is not found.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

Example:

\code
    QString x = "sticky question";
    QString y = "sti";
    x.indexOf(y);               // returns 0
    x.indexOf(y, 1);            // returns 10
    x.indexOf(y, 10);           // returns 10
    x.indexOf(y, 11);           // returns -1
\endcode

If <i>from</i> is -1, the search starts at the last character; if it is -2, at the next to last character and so on.

<b>See also </b>lastIndexOf(), contains(), and count().


*/


/*!
\fn int QString::indexOf ( QChar ch, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads indexOf().

Returns the index position of the first occurrence of the character <i>ch</i> in the string, searching forward from index position <i>from</i>. 
Returns -1 if <i>ch</i> could not be found.


*/


/*!
\fn int QString::indexOf ( const QStringRef & str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads indexOf().

Returns the index position of the first occurrence of the string reference <i>str</i> in this string, searching forward from index position <i>from</i>. 
Returns -1 if <i>str</i> is not found.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

*/


/*!
\fn int QString::indexOf ( const QRegExp & rx, int from = 0 ) const

This function overloads indexOf().

Returns the index position of the first match of the regular expression <i>rx</i> in the string, searching forward from index position <i>from</i>. 
Returns -1 if <i>rx</i> did not match anywhere.

Example:

\code
    QString str = "the minimum";
    str.indexOf(QRegExp("m[aeiou]"), 0);       // returns 4
\endcode


*/


/*!
\fn int QString::indexOf ( QRegExp & rx, int from = 0 ) const

This function overloads indexOf().

Returns the index position of the first match of the regular expression <i>rx</i> in the string, searching forward from index position <i>from</i>. 
Returns -1 if <i>rx</i> did not match anywhere.

If there is a match, the <i>rx</i> regular expression will contain the matched captures (see QRegExp::matchedLength, QRegExp::cap).

Example:

\code
    QString str = "the minimum";
    str.indexOf(QRegExp("m[aeiou]"), 0);       // returns 4
\endcode

*/


/*!
\fn QString & QString::insert ( int position, const QString & str )

Inserts the string <i>str</i> at the given index <i>position</i> and returns a reference to this string.

Example:

\code
    QString str = "Meal";
    str.insert(1, QString("ontr"));
    // str == "Montreal"
\endcode

If the given <i>position</i> is greater than size(), the array is first extended using resize().

<b>See also </b>append(), prepend(), replace(), and remove().


*/


/*!
\fn QString & QString::insert ( int position, const QLatin1String & str )

This function overloads insert().

Inserts the Latin-1 string <i>str</i> at the given index <i>position</i>.


*/


/*!
\fn QString & QString::insert ( int position, const QChar * unicode, int size )

This function overloads insert().

Inserts the first <i>size</i> characters of the QChar array <i>unicode</i> at the given index <i>position</i> in the string.


*/


/*!
\fn QString & QString::insert ( int position, QChar ch )

This function overloads insert().

Inserts <i>ch</i> at the given index <i>position</i> in the string.


*/


/*!
\fn bool QString::isEmpty () const

Returns true if the string has no characters; otherwise returns false.

Example:

\code
    QString().isEmpty();            // returns true
    QString("").isEmpty();          // returns true
    QString("x").isEmpty();         // returns false
    QString("abc").isEmpty();       // returns false
\endcode

<b>See also </b>size().


*/


/*!
\fn bool QString::isNull () const

Returns true if this string is null; otherwise returns false.

Example:

\code
    QString().isNull();             // returns true
    QString("").isNull();           // returns false
    QString("abc").isNull();        // returns false
\endcode

Qt makes a distinction between null strings and empty strings for historical reasons. For most applications, what matters is whether or not a string
contains any data, and this can be determined using the isEmpty() function.

<b>See also </b>isEmpty().


*/


/*!
\fn bool QString::isRightToLeft () const

Returns true if the string is read right to left.


*/


/*!
\fn int QString::lastIndexOf ( const QString & str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Returns the index position of the last occurrence of the string <i>str</i> in this string, searching backward from index position <i>from</i>. 
If <i>from</i> is -1 (default), the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1 if 
<i>str</i> is not found.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

Example:

\code
    QString x = "crazy azimuths";
    QString y = "az";
    x.lastIndexOf(y);           // returns 6
    x.lastIndexOf(y, 6);        // returns 6
    x.lastIndexOf(y, 5);        // returns 2
    x.lastIndexOf(y, 1);        // returns -1
\endcode

<b>See also </b>indexOf(), contains(), and count().


*/


/*!
\fn int QString::lastIndexOf ( const QLatin1String & str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads lastIndexOf().

Returns the index position of the last occurrence of the string <i>str</i> in this string, searching backward from index position <i>from</i>.
If <i>from</i> is -1 (default), the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1
if <i>str</i> is not found.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

Example:

\code
    QString x = "crazy azimuths";
    QString y = "az";
    x.lastIndexOf(y);           // returns 6
    x.lastIndexOf(y, 6);        // returns 6
    x.lastIndexOf(y, 5);        // returns 2
    x.lastIndexOf(y, 1);        // returns -1
\endcode

<b>See also </b>indexOf(), contains(), and count().


*/


/*!
\fn int QString::lastIndexOf ( QChar ch, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads lastIndexOf().

Returns the index position of the last occurrence of the character <i>ch</i>, searching backward from position <i>from</i>.


*/


/*!
\fn int QString::lastIndexOf ( const QStringRef & str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads lastIndexOf().

Returns the index position of the last occurrence of the string reference <i>str</i> in this string, searching backward from index position <i>from</i>. 
If <i>from</i> is -1 (default), the search starts at the last character; if <i>from</i> is -2, at the next to last character and so on. Returns -1 if 
<i>str</i> is not found.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>See also </b>indexOf(), contains(), and count().


*/


/*!
\fn int QString::lastIndexOf ( const QRegExp & rx, int from = -1 ) const

This function overloads lastIndexOf().

Returns the index position of the last match of the regular expression <i>rx</i> in the string, searching backward from index position <i>from</i>. 
Returns -1 if <i>rx</i> didn't match anywhere.

Example:

\code
    QString str = "the minimum";
    str.lastIndexOf(QRegExp("m[aeiou]"));      // returns 8
\endcode


*/


/*!
\fn int QString::lastIndexOf ( QRegExp & rx, int from = -1 ) const

This function overloads lastIndexOf().

Returns the index position of the last match of the regular expression <i>rx</i> in the string, searching backward from index position <i>from</i>.
Returns -1 if <i>rx</i> didn't match anywhere.

If there is a match, the <i>rx</i> regular expression will contain the matched captures (see QRegExp::matchedLength, QRegExp::cap).

Example:

\code
    QString str = "the minimum";
    str.lastIndexOf(QRegExp("m[aeiou]"));      // returns 8
\endcode

*/


/*!
\fn QString QString::left ( int n ) const

Returns a substring that contains the <i>n</i> leftmost characters of the string.

The entire string is returned if <i>n</i> is greater than size() or less than zero.

\code
    QString x = "Pineapple";
    QString y = x.left(4);      // y == "Pine"
\endcode

<b>See also </b>right(), mid(), and startsWith().


*/


/*!
\fn QString QString::leftJustified ( int width, QChar fill = QLatin1Char( ' ' ), bool truncate = false ) const

Returns a string of size <i>width</i> that contains this string padded by the <i>fill</i> character.

If <i>truncate</i> is false and the size() of the string is more than <i>width</i>, then the returned string is a copy of the string.

\code
    QString s = "apple";
    QString t = s.leftJustified(8, '.');    // t == "apple..."
\endcode

If <i>truncate</i> is true and the size() of the string is more than <i>width</i>, then any characters in a copy of the string after position <i>width</i> are removed, and the copy is returned.

\code
    QString str = "Pineapple";
    str = str.leftJustified(5, '.', true);    // str == "Pinea"
\endcode

<b>See also </b>rightJustified().


*/


/*!
\fn QStringRef QString::leftRef ( int n ) const

Returns a substring reference to the <i>n</i> leftmost characters of the string.

If <i>n</i> is greater than size() or less than zero, a reference to the entire string is returned.

\code
    QString x = "Pineapple";
    QStringRef y = x.leftRef(4);        // y == "Pine"
\endcode

<b>See also </b>left(), rightRef(), midRef(), and startsWith().

*/


/*!
\fn int QString::length () const

Returns the number of characters in this string. Equivalent to size().

<b>See also </b>resize().


*/


/*!
\fn int QString::localeAwareCompare ( const QString & s1, const QString & s2 ) [static]

Compares <i>s1</i> with <i>s2</i> and returns an integer less than, equal to, or greater than zero if <i>s1</i> is less than, equal to, or greater than <i>s2</i>.

The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.

On Mac OS X since Qt 4.3, this function compares according the &quot;Order for sorted lists&quot; setting in the International prefereces panel.

<b>See also </b>compare() and QTextCodec::locale().


*/


/*!
\fn int QString::localeAwareCompare ( const QStringRef & other ) const

This function overloads localeAwareCompare().

Compares this string with the <i>other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the <i>other</i> string.

The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.

Same as <tt>localeAwareCompare(*this, other)</tt>.


*/


/*!
\fn int QString::localeAwareCompare ( const QString & s1, const QStringRef & s2 ) [static]

This function overloads localeAwareCompare().

Compares <i>s1</i> with <i>s2</i> and returns an integer less than, equal to, or greater than zero if <i>s1</i> is less than, equal to, or greater than <i>s2</i>.

The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.

This function was introduced in Qt 4.5.


*/


/*!
\fn int QString::localeAwareCompare ( const QString & other ) const

This function overloads localeAwareCompare().

Compares this string with the <i>other</i> string and returns an integer less than, equal to, or greater than zero if this string is less than, equal to, or greater than the <i>other</i> string.

The comparison is performed in a locale- and also platform-dependent manner. Use this function to present sorted lists of strings to the user.

Same as <tt>localeAwareCompare(*this, other)</tt>.


*/


/*!
\fn QString QString::mid ( int position, int n = -1 ) const

Returns a string that contains <i>n</i> characters of this string, starting at the specified <i>position</i> index.

Returns a null string if the <i>position</i> index exceeds the length of the string. If there are less than <i>n</i> characters available in the string starting at the given <i>position</i>, or if <i>n</i> is -1 (default), the function returns all characters that are available from the specified <i>position</i>.

Example:

\code
    QString x = "Nine pineapples";
    QString y = x.mid(5, 4);            // y == "pine"
    QString z = x.mid(5);               // z == "pineapples"
\endcode

<b>See also </b>left() and right().


*/


/*!
\fn QStringRef QString::midRef ( int position, int n = -1 ) const

Returns a substring reference to <i>n</i> characters of this string, starting at the specified <i>position</i>.

If the <i>position</i> exceeds the length of the string, an empty reference is returned.

If there are less than <i>n</i> characters available in the string, starting at the given <i>position</i>, or if <i>n</i> is -1 (default), the function returns all characters from the specified <i>position</i> onwards.

Example:

\code
    QString x = "Nine pineapples";
    QStringRef y = x.midRef(5, 4);      // y == "pine"
    QStringRef z = x.midRef(5);         // z == "pineapples"
\endcode

This function was introduced in Qt 4.4.

<b>See also </b>mid(), leftRef(), and rightRef().


*/


/*!
\fn QString QString::normalized ( NormalizationForm mode ) const

Returns the string in the given Unicode normalization <i>mode</i>.


*/


/*!
\fn QString QString::normalized ( NormalizationForm mode, QChar::UnicodeVersion version ) const

This is an overloaded function.

Returns the string in the given Unicode normalization <i>mode</i>, according to the given <i>version</i> of the Unicode standard.


*/


/*!
\fn QString QString::number ( long n, int base = 10 ) [static]

Returns a string equivalent of the number <i>n</i> according to the specified <i>base</i>.

The base is 10 by default and must be between 2 and 36. For bases other than 10, <i>n</i> is treated as an unsigned integer.

\code
    long a = 63;
    QString s = QString::number(a, 16);             // s == "3f"
    QString t = QString::number(a, 16).toUpper();     // t == "3F"
\endcode

<b>See also </b>setNum().


*/


/*!
\fn QString QString::number ( double n, char format = 'g', int precision = 6 ) [static]

Returns a string equivalent of the number <i>n</i>, formatted according to the specified <i>format</i> and <i>precision</i>. See Argument Formats for details.

Unlike QLocale::toString(), this function does not honor the user's locale settings.

<b>See also </b>setNum() and QLocale::toString().


*/


/*!
\fn QString QString::number ( ulong n, int base = 10 ) [static]

This is an overloaded function.


*/


/*!
\fn QString QString::number ( int n, int base = 10 ) [static]

This is an overloaded function.


*/


/*!
\fn QString QString::number ( uint n, int base = 10 ) [static]

This is an overloaded function.


*/


/*!
\fn QString QString::number ( qlonglong n, int base = 10 ) [static]

This is an overloaded function.


*/


/*!
\fn QString QString::number ( qulonglong n, int base = 10 ) [static]

This is an overloaded function.


*/


/*!
\fn QString & QString::prepend ( const QString & str )

Prepends the string <i>str</i> to the beginning of this string and returns a reference to this string.

Example:

\code
    QString x = "ship";
    QString y = "air";
    x.prepend(y);
    // x == "airship"
\endcode

<b>See also </b>append() and insert().


*/


/*!
\fn QString & QString::prepend ( const QLatin1String & str )

This function overloads prepend().

Prepends the Latin-1 string <i>str</i> to this string.


*/


/*!
\fn QString & QString::prepend ( const QByteArray & ba )

This function overloads prepend().

Prepends the byte array <i>ba</i> to this string. The byte array is converted to Unicode using the fromAscii() function.

You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::prepend ( const char * str )

This function overloads prepend().

Prepends the string <i>str</i> to this string. The const char pointer is converted to Unicode using the fromAscii() function.

You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::prepend ( QChar ch )

This function overloads prepend().

Prepends the character <i>ch</i> to this string.


*/


/*!
\fn void QString::push_back ( const QString & other )

This function is provided for STL compatibility, appending the given <i>other</i> string onto the end of this string. It is equivalent to <tt>append(other)</tt>.

<b>See also </b>append().


*/


/*!
\fn void QString::push_back ( QChar ch )

This is an overloaded function.

Appends the given <i>ch</i> character onto the end of this string.


*/


/*!
\fn void QString::push_front ( const QString & other )

This function is provided for STL compatibility, prepending the given <i>other</i> string to the beginning of this string. It is equivalent to <tt>prepend(other)</tt>.

<b>See also </b>prepend().


*/


/*!
\fn void QString::push_front ( QChar ch )

This is an overloaded function.

Prepends the given <i>ch</i> character to the beginning of this string.


*/


/*!
\fn QString & QString::remove ( int position, int n )

Removes <i>n</i> characters from the string, starting at the given <i>position</i> index, and returns a reference to the string.

If the specified <i>position</i> index is within the string, but <i>position</i> + <i>n</i> is beyond the end of the string, the string is truncated at the specified <i>position</i>.

\code
    QString s = "Montreal";
    s.remove(1, 4);
    // s == "Meal"
\endcode

<b>See also </b>insert() and replace().


*/


/*!
\fn QString & QString::remove ( QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive )

Removes every occurrence of the character <i>ch</i> in this string, and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

Example:

\code
    QString t = "Ali Baba";
    t.remove(QChar('a'), Qt::CaseSensitive);
    // t == "li Bb"
\endcode

This is the same as <tt>replace(ch, &quot;&quot;, cs)</tt>.

<b>See also </b>replace().


*/


/*!
\fn QString & QString::remove ( const QString & str, Qt::CaseSensitivity cs = Qt::CaseSensitive )

Removes every occurrence of the given <i>str</i> string in this string, and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

This is the same as <tt>replace(str, &quot;&quot;, cs)</tt>.

<b>See also </b>replace().


*/


/*!
\fn QString & QString::remove ( const QRegExp & rx )

Removes every occurrence of the regular expression <i>rx</i> in the string, and returns a reference to the string. For example:

\code
    QString r = "Telephone";
    r.remove(QRegExp("[aeiou]."));
    // r == "The"
\endcode

<b>See also </b>indexOf(), lastIndexOf(), and replace().


*/


/*!
\fn QString QString::repeated ( int times ) const

Returns a copy of this string repeated the specified number of <i>times</i>.

If <i>times</i> is less than 1, an empty string is returned.

Example:

\code
    QString str("ab");
    str.repeated(4);            // returns "abababab"
\endcode

This function was introduced in Qt 4.5.


*/


/*!
\fn QString & QString::replace ( int position, int n, const QString & after )

Replaces <i>n</i> characters beginning at index <i>position</i> with the string <i>after</i> and returns a reference to this string.

Example:

\code
    QString x = "Say yes!";
    QString y = "no";
    x.replace(4, 3, y);
    // x == "Say no!"
\endcode

<b>See also </b>insert() and remove().


*/


/*!
\fn QString & QString::replace ( int position, int n, const QChar * unicode, int size )

This function overloads replace().

Replaces <i>n</i> characters beginning at index <i>position</i> with the first <i>size</i> characters of the QChar array <i>unicode</i> and returns a reference to this string.


*/


/*!
\fn QString & QString::replace ( int position, int n, QChar after )

This function overloads replace().

Replaces <i>n</i> characters beginning at index <i>position</i> with the character <i>after</i> and returns a reference to this string.


*/


/*!
\fn QString & QString::replace ( const QString & before, const QString & after, Qt::CaseSensitivity cs = Qt::CaseSensitive )

This function overloads replace().

Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

Example:

\code
    QString str = "colour behaviour flavour neighbour";
    str.replace(QString("ou"), QString("o"));
    // str == "color behavior flavor neighbor"
\endcode

<b>Note:</b> The replacement text is not rescanned after it is inserted.

Example:

\code
    QString equis = "xxxxxx";
    equis.replace("xx", "x");
    // equis == "xxx"
\endcode


*/


/*!
\fn QString & QString::replace ( const QChar * before, int blen, const QChar * after, int alen, Qt::CaseSensitivity cs = Qt::CaseSensitive )

This function overloads replace().

Replaces each occurrence in this string of the first <i>blen</i> characters of <i>before</i> with the first <i>alen</i> characters of <i>after</i> and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

This function was introduced in Qt 4.5.


*/


/*!
\fn QString & QString::replace ( QChar ch, const QString & after, Qt::CaseSensitivity cs = Qt::CaseSensitive )

This function overloads replace().

Replaces every occurrence of the character <i>ch</i> in the string with <i>after</i> and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.


*/


/*!
\fn QString & QString::replace ( QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive )

This function overloads replace().

Replaces every occurrence of the character <i>before</i> with the character <i>after</i> and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.


*/


/*!
\fn QString & QString::replace ( const QLatin1String & before, const QLatin1String & after, Qt::CaseSensitivity cs = Qt::CaseSensitive )

This function overloads replace().

Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>Note:</b> The text is not rescanned after a replacement.

This function was introduced in Qt 4.5.


*/


/*!
\fn QString & QString::replace ( const QLatin1String & before, const QString & after, Qt::CaseSensitivity cs = Qt::CaseSensitive )

This function overloads replace().

Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>Note:</b> The text is not rescanned after a replacement.

This function was introduced in Qt 4.5.


*/


/*!
\fn QString & QString::replace ( const QString & before, const QLatin1String & after, Qt::CaseSensitivity cs = Qt::CaseSensitive )

This function overloads replace().

Replaces every occurrence of the string <i>before</i> with the string <i>after</i> and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>Note:</b> The text is not rescanned after a replacement.

This function was introduced in Qt 4.5.


*/


/*!
\fn QString & QString::replace ( QChar c, const QLatin1String & after, Qt::CaseSensitivity cs = Qt::CaseSensitive )

This function overloads replace().

Replaces every occurrence of the character <i>c</i> with the string <i>after</i> and returns a reference to this string.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>Note:</b> The text is not rescanned after a replacement.

This function was introduced in Qt 4.5.


*/


/*!
\fn QString & QString::replace ( const QRegExp & rx, const QString & after )

This function overloads replace().

Replaces every occurrence of the regular expression <i>rx</i> in the string with <i>after</i>. Returns a reference to the string. For example:

\code
    QString s = "Banana";
    s.replace(QRegExp("a[mn]"), "ox");
    // s == "Boxoxa"
\endcode

For regular expressions containing capturing parentheses, occurrences of <b>\1</b>, <b>\2</b>, ..., in <i>after</i> are replaced with <i>rx</i>.cap(1), cap(2), ...

\code
    QString t = "A <i>bon mot</i>.";
    t.replace(QRegExp("<i>([^<]*)</i>"), "\\emph{\\1}");
    // t == "A \\emph{bon mot}."
\endcode

<b>See also </b>indexOf(), lastIndexOf(), remove(), and QRegExp::cap().


*/


/*!
\fn void QString::reserve ( int size )

Attempts to allocate memory for at least <i>size</i> characters. If you know in advance how large the string will be, you can call this function, and if you resize the string often you are likely to get better performance. If <i>size</i> is an underestimate, the worst that will happen is that the QString will be a bit slower.

The sole purpose of this function is to provide a means of fine tuning QString's memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the string, call resize().

This function is useful for code that needs to build up a long string and wants to avoid repeated reallocation. In this example, we want to add to the string until some condition is true, and we're fairly sure that size is large enough to make a call to reserve() worthwhile:

\code
    QString result;
    int maxSize;
    bool condition;
    QChar nextChar;

    result.reserve(maxSize);

    while (condition)
        result.append(nextChar);

    result.squeeze();
\endcode

<b>See also </b>squeeze() and capacity().


*/


/*!
\fn void QString::resize ( int size )

Sets the size of the string to <i>size</i> characters.

If <i>size</i> is greater than the current size, the string is extended to make it <i>size</i> characters long with the extra characters added to the end. The new characters are uninitialized.

If <i>size</i> is less than the current size, characters are removed from the end.

Example:

\code
    QString s = "Hello world";
    s.resize(5);
    // s == "Hello"

    s.resize(8);
    // s == "Hello???" (where ? stands for any character)
\endcode

If you want to append a certain number of identical characters to the string, use operator+=() as follows rather than resize():

\code
    QString t = "Hello";
    t += QString(10, 'X');
    // t == "HelloXXXXXXXXXX"
\endcode

If you want to expand the string so that it reaches a certain width and fill the new positions with a particular character, use the leftJustified() function:

If <i>size</i> is negative, it is equivalent to passing zero.

\code
    QString r = "Hello";
    r = r.leftJustified(10, ' ');
    // r == "Hello     "
\endcode

<b>See also </b>truncate() and reserve().


*/


/*!
\fn QString QString::right ( int n ) const

Returns a substring that contains the <i>n</i> rightmost characters of the string.

The entire string is returned if <i>n</i> is greater than size() or less than zero.

\code
    QString x = "Pineapple";
    QString y = x.right(5);      // y == "apple"
\endcode

<b>See also </b>left(), mid(), and endsWith().


*/


/*!
\fn QString QString::rightJustified ( int width, QChar fill = QLatin1Char( ' ' ), bool truncate = false ) const

Returns a string of size() <i>width</i> that contains the <i>fill</i> character followed by the string. For example:

\code
    QString s = "apple";
    QString t = s.rightJustified(8, '.');    // t == "...apple"
\endcode

If <i>truncate</i> is false and the size() of the string is more than <i>width</i>, then the returned string is a copy of the string.

If <i>truncate</i> is true and the size() of the string is more than <i>width</i>, then the resulting string is truncated at position <i>width</i>.

\code
    QString str = "Pineapple";
    str = str.rightJustified(5, '.', true);    // str == "Pinea"
\endcode

<b>See also </b>leftJustified().


*/


/*!
\fn QStringRef QString::rightRef ( int n ) const

Returns a substring reference to the <i>n</i> rightmost characters of the string.

If <i>n</i> is greater than size() or less than zero, a reference to the entire string is returned.

\code
    QString x = "Pineapple";
    QStringRef y = x.rightRef(5);       // y == "apple"
\endcode

This function was introduced in Qt 4.4.

<b>See also </b>right(), leftRef(), midRef(), and endsWith().


*/


/*!
\fn QString QString::section ( QChar sep, int start, int end = -1, SectionFlags flags = SectionDefault ) const

This function returns a section of the string.

This string is treated as a sequence of fields separated by the character, <i>sep</i>. The returned string consists of the fields from position <i>start</i> to position <i>end</i> inclusive. If <i>end</i> is not specified, all fields from position <i>start</i> to the end of the string are included. Fields are numbered 0, 1, 2, etc., counting from the left, and -1, -2, etc., counting from right to left.

The <i>flags</i> argument can be used to affect some aspects of the function's behavior, e.g. whether to be case sensitive, whether to skip empty fields and how to deal with leading and trailing separators; see SectionFlags.

\code
    QString str;
    QString csv = "forename,middlename,surname,phone";
    QString path = "/usr/local/bin/myapp"; // First field is empty
    QString::SectionFlag flag = QString::SectionSkipEmpty;

    str = csv.section(',', 2, 2);   // str == "surname"
    str = path.section('/', 3, 4);  // str == "bin/myapp"
    str = path.section('/', 3, 3, flag); // str == "myapp"
\endcode

If <i>start</i> or <i>end</i> is negative, we count fields from the right of the string, the right-most field being -1, the one from right-most field being -2, and so on.

\code
    str = csv.section(',', -3, -2);  // str == "middlename,surname"
    str = path.section('/', -1); // str == "myapp"
\endcode

<b>See also </b>split().


*/


/*!
\fn QString QString::section ( const QString & sep, int start, int end = -1, SectionFlags flags = SectionDefault ) const

This function overloads section().

\code
    QString str;
    QString data = "forename**middlename**surname**phone";

    str = data.section("**", 2, 2); // str == "surname"
    str = data.section("**", -3, -2); // str == "middlename**surname"
\endcode

<b>See also </b>split().


*/


/*!
\fn QString QString::section ( const QRegExp & reg, int start, int end = -1, SectionFlags flags = SectionDefault ) const

This function overloads section().

This string is treated as a sequence of fields separated by the regular expression, <i>reg</i>.

\code
    QString line = "forename\tmiddlename  surname \t \t phone";
    QRegExp sep("\\s+");
    str = line.section(sep, 2, 2); // s == "surname"
    str = line.section(sep, -3, -2); // s == "middlename  surname"
\endcode

<b>Warning:</b> Using this QRegExp version is much more expensive than the overloaded string and character versions.

<b>See also </b>split() and simplified().


*/


/*!
\fn QString & QString::setNum ( int n, int base = 10 )

Sets the string to the printed value of <i>n</i> in the specified <i>base</i>, and returns a reference to the string.

The base is 10 by default and must be between 2 and 36. For bases other than 10, <i>n</i> is treated as an unsigned integer.

\code
    QString str;
    str.setNum(1234);       // str == "1234"
\endcode

The formatting always uses QLocale::C, i.e., English/UnitedStates. To get a localized string representation of a number, use QLocale::toString() with the appropriate locale.


*/


/*!
\fn QString & QString::setNum ( uint n, int base = 10 )

This is an overloaded function.


*/


/*!
\fn QString & QString::setNum ( long n, int base = 10 )

This is an overloaded function.


*/


/*!
\fn QString & QString::setNum ( ulong n, int base = 10 )

This is an overloaded function.


*/


/*!
\fn QString & QString::setNum ( qlonglong n, int base = 10 )

This is an overloaded function.


*/


/*!
\fn QString & QString::setNum ( qulonglong n, int base = 10 )

This is an overloaded function.


*/


/*!
\fn QString & QString::setNum ( short n, int base = 10 )

This is an overloaded function.


*/


/*!
\fn QString & QString::setNum ( ushort n, int base = 10 )

This is an overloaded function.


*/


/*!
\fn QString & QString::setNum ( double n, char format = 'g', int precision = 6 )

This is an overloaded function.

Sets the string to the printed value of <i>n</i>, formatted according to the given <i>format</i> and <i>precision</i>, and returns a reference to the string.

The <i>format</i> can be 'f', 'F', 'e', 'E', 'g' or 'G' (see the arg() function documentation for an explanation of the formats).

Unlike QLocale::toString(), this function doesn't honor the user's locale settings.


*/


/*!
\fn QString & QString::setNum ( float n, char format = 'g', int precision = 6 )

This is an overloaded function.

Sets the string to the printed value of <i>n</i>, formatted according to the given <i>format</i> and <i>precision</i>, and returns a reference to the string.


*/


/*!
\fn QString & QString::setRawData ( const QChar * unicode, int size )

Resets the QString to use the first <i>size</i> Unicode characters in the array <i>unicode</i>. The data in <i>unicode</i> is <i>not</i> copied. The caller must be able to guarantee that <i>unicode</i> will not be deleted or modified as long as the QString (or an unmodified copy of it) exists.

This function can be used instead of fromRawData() to re-use existings QString objects to save memory re-allocations.

This function was introduced in Qt 4.7.

<b>See also </b>fromRawData().


*/


/*!
\fn QString & QString::setUnicode ( const QChar * unicode, int size )

Resizes the string to <i>size</i> characters and copies <i>unicode</i> into the string.

If <i>unicode</i> is 0, nothing is copied, but the string is still resized to <i>size</i>.

<b>See also </b>unicode() and setUtf16().


*/


/*!
\fn QString & QString::setUtf16 ( const ushort * unicode, int size )

Resizes the string to <i>size</i> characters and copies <i>unicode</i> into the string.

If <i>unicode</i> is 0, nothing is copied, but the string is still resized to <i>size</i>.

Note that unlike fromUtf16(), this function does not consider BOMs and possibly differing byte ordering.

<b>See also </b>utf16() and setUnicode().


*/


/*!
\fn QString QString::simplified () const

Returns a string that has whitespace removed from the start and the end, and that has each sequence of internal whitespace replaced with a single space.

Whitespace means any character for which QChar::isSpace() returns true. This includes the ASCII characters '\\t', '\\n', '\\v', '\\f', '\\r', and ' '.

Example:

\code
    QString str = "  lots\t of\nwhitespace\r\n ";
    str = str.simplified();
    // str == "lots of whitespace";
\endcode

<b>See also </b>trimmed().


*/


/*!
\fn int QString::size () const

Returns the number of characters in this string.

The last character in the string is at position size() - 1. In addition, QString ensures that the character at position size() is always '\0', so that you can use the return value of data() and constData() as arguments to functions that expect '\0'-terminated strings.

Example:

\code
    QString str = "World";
    int n = str.size();         // n == 5
    str.data()[0];              // returns 'W'
    str.data()[4];              // returns 'd'
    str.data()[5];              // returns '\0'
\endcode

<b>See also</b> isEmpty() and resize().


*/


/*!
\fn QStringList QString::split ( const QString & sep, SplitBehavior behavior = KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Splits the string into substrings wherever <i>sep</i> occurs, and returns the list of those strings. If <i>sep</i> does not match anywhere in the string, split() returns a single-element list containing this string.

<i>cs</i> specifies whether <i>sep</i> should be matched case sensitively or case insensitively.

If <i>behavior</i> is QString::SkipEmptyParts, empty entries don't appear in the result. By default, empty entries are kept.

Example:

\code
    QString str = "a,,b,c";

    QStringList list1 = str.split(",");
    // list1: [ "a", "", "b", "c" ]

    QStringList list2 = str.split(",", QString::SkipEmptyParts);
    // list2: [ "a", "b", "c" ]
\endcode

<b>See also</b> QStringList::join() and section().


*/


/*!
\fn QStringList QString::split ( QChar sep, SplitBehavior behavior = KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This is an overloaded function.


*/


/*!
\fn QStringList QString::split ( const QRegExp & rx, SplitBehavior behavior = KeepEmptyParts ) const

This is an overloaded function.

Splits the string into substrings wherever the regular expression <i>rx</i> matches, and returns the list of those strings. If <i>rx</i> does not match anywhere in the string, split() returns a single-element list containing this string.

Here's an example where we extract the words in a sentence using one or more whitespace characters as the separator:

\code
    QString str;
    QStringList list;

    str = "Some  text\n\twith  strange whitespace.";
    list = str.split(QRegExp("\\s+"));
    // list: [ "Some", "text", "with", "strange", "whitespace." ]
\endcode

Here's a similar example, but this time we use any sequence of non-word characters as the separator:

\code
    str = "This time, a normal English sentence.";
    list = str.split(QRegExp("\\W+"), QString::SkipEmptyParts);
    // list: [ "This", "time", "a", "normal", "English", "sentence" ]
\endcode

Here's a third example where we use a zero-length assertion, <b>\\b</b> (word boundary), to split the string into an alternating sequence of non-word and word tokens:

\code
    str = "Now: this sentence fragment.";
    list = str.split(QRegExp("\\b"));
    // list: [ "", "Now", ": ", "this", " ", "sentence", " ", "fragment", "." ]
\endcode

<b>See also </b>QStringList::join() and section().


*/


/*!
\fn QString & QString::sprintf ( const char * cformat, ... )

Safely builds a formatted string from the format string <i>cformat</i> and an arbitrary list of arguments.

The %lc escape sequence expects a unicode character of type ushort (as returned by QChar::unicode()). The %ls escape sequence expects a pointer to a zero-terminated array of unicode characters of type ushort (as returned by QString::utf16()).

<b>Note:</b> This function expects a UTF-8 string for %s and Latin-1 for the format string.

The format string supports most of the conversion specifiers provided by printf() in the standard C++ library. It doesn't honor the length modifiers (e.g. <tt>h</tt> for <tt>short</tt>, <tt>ll</tt> for <tt>long long</tt>). If you need those, use the standard snprintf() function instead:

\code
    size_t BufSize;
    char buf[BufSize];

    ::snprintf(buf, BufSize, "%lld", 123456789LL);
    QString str = QString::fromAscii(buf);
\endcode

<b>Warning:</b> We do not recommend using QString::sprintf() in new Qt code. Instead, consider using QTextStream or arg(), both of which support Unicode strings seamlessly and are type-safe. Here's an example that uses QTextStream:

\code
    QString result;
    QTextStream(&result) << "pi = " << 3.14;
    // result == "pi = 3.14"
\endcode

For translations, especially if the strings contains more than one escape sequence, you should consider using the arg() function instead. This allows the order of the replacements to be controlled by the translator.

<b>See also </b>arg().


*/


/*!
\fn void QString::squeeze ()

Releases any memory not required to store the character data.

The sole purpose of this function is to provide a means of fine tuning QString's memory usage. In general, you will rarely ever need to call this function.

<b>See also </b>reserve() and capacity().


*/


/*!
\fn bool QString::startsWith ( const QString & s, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

Returns true if the string starts with <i>s</i>; otherwise returns false.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

\code
    QString str = "Bananas";
    str.startsWith("Ban");     // returns true
    str.startsWith("Car");     // returns false
\endcode

<b>See also </b>endsWith().


*/


/*!
\fn bool QString::startsWith ( const QLatin1String & s, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads startsWith().


*/


/*!
\fn bool QString::startsWith ( QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This function overloads startsWith().

Returns true if the string starts with <i>c</i>; otherwise returns false.


*/


/*!
\fn bool QString::startsWith ( const QStringRef & s, Qt::CaseSensitivity cs = Qt::CaseSensitive ) const

This is an overloaded function.

Returns true if the string starts with the string reference <i>s</i>; otherwise returns false.

If <i>cs</i> is Qt::CaseSensitive (default), the search is case sensitive; otherwise the search is case insensitive.

<b>See also </b>endsWith().


*/


/*!
\fn void QString::swap ( QString & other )

Swaps string <i>other</i> with this string. This operation is very fast and never fails.

This function was introduced in Qt 4.8.


*/


/*!
\fn QByteArray QString::toAscii () const

Returns an 8-bit representation of the string as a QByteArray.

If a codec has been set using QTextCodec::setCodecForCStrings(), it is used to convert Unicode to 8-bit char; otherwise this function does the same as toLatin1().

Note that, despite the name, this function does not necessarily return an US-ASCII (ANSI X3.4-1986) string and its result may not be US-ASCII compatible.

<b>See also </b>fromAscii(), toLatin1(), toUtf8(), toLocal8Bit(), and QTextCodec.


*/


/*!
\fn QString QString::toCaseFolded () const

Returns the case folded equivalent of the string. For most Unicode characters this is the same as toLower().


*/


/*!
\fn double QString::toDouble ( bool * ok = 0 ) const

Returns the string converted to a <tt>double</tt> value.

Returns 0.0 if the conversion fails.

If a conversion error occurs, <tt>*</tt><i>ok</i> is set to false; otherwise <tt>*</tt><i>ok</i> is set to true.

\code
    QString str = "1234.56";
    double val = str.toDouble();   // val == 1234.56
\endcode

Various string formats for floating point numbers can be converted to double values:

\code
    bool ok;
    double d;

    d = QString( "1234.56e-02" ).toDouble(&ok); // ok == true, d == 12.3456
\endcode

This function tries to interpret the string according to the current locale. The current locale is determined from the system at application startup and can be changed by calling QLocale::setDefault(). If the string cannot be interpreted according to the current locale, this function falls back on the &quot;C&quot; locale.

\code
    QLocale::setDefault(QLocale::C);
    d = QString( "1234,56" ).toDouble(&ok); // ok == false
    d = QString( "1234.56" ).toDouble(&ok); // ok == true, d == 1234.56

    QLocale::setDefault(QLocale::German);
    d = QString( "1234,56" ).toDouble(&ok); // ok == true, d == 1234.56
    d = QString( "1234.56" ).toDouble(&ok); // ok == true, d == 1234.56
\endcode

Due to the ambiguity between the decimal point and thousands group separator in various locales, this function does not handle thousands group separators. If you need to convert such numbers, see QLocale::toDouble().

\code
    QLocale::setDefault(QLocale::C);
    d = QString( "1234,56" ).toDouble(&ok); // ok == false
\endcode

<b>See also </b>number(), QLocale::setDefault(), QLocale::toDouble(), and trimmed().


*/


/*!
\fn float QString::toFloat ( bool * ok = 0 ) const

Returns the string converted to a <tt>float</tt> value.

If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true. Returns 0.0 if the conversion fails.

Example:

\code
    QString str1 = "1234.56";
    str1.toFloat();             // returns 1234.56

    bool ok;
    QString str2 = "R2D2";
    str2.toFloat(&ok);          // returns 0.0, sets ok to false
\endcode

<b>See also </b>number(), toDouble(), and toInt().


*/


/*!
\fn int QString::toInt ( bool * ok = 0, int base = 10 ) const

Returns the string converted to an <tt>int</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.

If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.

If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.

Example:

\code
    QString str = "FF";
    bool ok;
    int hex = str.toInt(&ok, 16);       // hex == 255, ok == true
    int dec = str.toInt(&ok, 10);       // dec == 0, ok == false
\endcode

<b>See also </b>number(), toUInt(), and toDouble().


*/


/*!
\fn QByteArray QString::toLatin1 () const

Returns a Latin-1 representation of the string as a QByteArray.

The returned byte array is undefined if the string contains non-Latin1 characters. Those characters may be suppressed or replaced with a question mark.

<b>See also </b>fromLatin1(), toAscii(), toUtf8(), toLocal8Bit(), and QTextCodec.


*/


/*!
\fn QByteArray QString::toLocal8Bit () const

Returns the local 8-bit representation of the string as a QByteArray. The returned byte array is undefined if the string contains characters not supported by the local 8-bit encoding.

QTextCodec::codecForLocale() is used to perform the conversion from Unicode. If the locale encoding could not be determined, this function does the same as toLatin1().

If this string contains any characters that cannot be encoded in the locale, the returned byte array is undefined. Those characters may be suppressed or replaced by another.

<b>See also </b>fromLocal8Bit(), toAscii(), toLatin1(), toUtf8(), and QTextCodec.


*/


/*!
\fn long QString::toLong ( bool * ok = 0, int base = 10 ) const

Returns the string converted to a <tt>long</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if the conversion fails.

If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.

If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.

Example:

\code
    QString str = "FF";
    bool ok;

    long hex = str.toLong(&ok, 16);     // hex == 255, ok == true
    long dec = str.toLong(&ok, 10);     // dec == 0, ok == false
\endcode

<b>See also </b>number(), toULong(), and toInt().


*/


/*!
\fn qlonglong QString::toLongLong ( bool * ok = 0, int base = 10 ) const

Returns the string converted to a <tt>long long</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0
if the conversion fails.

If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.

If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with
&quot;0&quot;, base 8 is used; otherwise, base 10 is used.

Example:

\code
    QString str = "FF";
    bool ok;

    qint64 hex = str.toLongLong(&ok, 16);      // hex == 255, ok == true
    qint64 dec = str.toLongLong(&ok, 10);      // dec == 0, ok == false
\endcode

<b>See also </b>number(), toULongLong(), and toInt().


*/


/*!
\fn QString QString::toLower () const

Returns a lowercase copy of the string.

\code
    QString str = "CopperSpice";
    str = str.toLower();        // str == "copperspice"
\endcode

The case conversion will always happen in the 'C' locale. For locale dependent case folding use QLocale::toLower()

<b>See also </b>toUpper() and QLocale::toLower().


*/


/*!
\fn short QString::toShort ( bool * ok = 0, int base = 10 ) const

Returns the string converted to a <tt>short</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 if
the conversion fails.

If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.

If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with
&quot;0&quot;, base 8 is used; otherwise, base 10 is used.

Example:

\code
    QString str = "FF";
    bool ok;

    short hex = str.toShort(&ok, 16);   // hex == 255, ok == true
    short dec = str.toShort(&ok, 10);   // dec == 0, ok == false
\endcode

<b>See also </b>number(), toUShort(), and toInt().


*/


/*!
\fn std::string QString::toStdString () const

Returns a std::string object with the data contained in this QString. The Unicode data is converted into 8-bit characters using the toAscii() function.

This operator is mostly useful to pass a QString to a function that accepts a std::string object.

If the QString contains Unicode characters that the QTextCodec::codecForCStrings() codec cannot handle, using this operator can lead to loss of information.

This operator is only available if Qt is configured with STL compatibility enabled.

<b>See also </b>toAscii(), toLatin1(), toUtf8(), and toLocal8Bit().


*/


/*!
\fn QStdWString QString::toStdWString () const

Returns a std::wstring object with the data contained in this QString. The std::wstring is encoded in utf16 on platforms where wchar_t is 2 bytes
wide (e.g. windows) and in ucs4 on platforms where wchar_t is 4 bytes wide (most Unix systems).

This operator is mostly useful to pass a QString to a function that accepts a std::wstring object.

This operator is only available if Qt is configured with STL compatibility enabled.

<b>See also </b>utf16(), toAscii(), toLatin1(), toUtf8(), and toLocal8Bit().


*/


/*!
\fn uint QString::toUInt ( bool * ok = 0, int base = 10 ) const

Returns the string converted to an <tt>unsigned int</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0
if the conversion fails.

If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.

If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with
&quot;0&quot;, base 8 is used; otherwise, base 10 is used.

Example:

\code
    QString str = "FF";
    bool ok;

    uint hex = str.toUInt(&ok, 16);     // hex == 255, ok == true
    uint dec = str.toUInt(&ok, 10);     // dec == 0,   ok == false
\endcode

<b>See also </b>number() and toInt().


*/


/*!
\fn ulong QString::toULong ( bool * ok = 0, int base = 10 ) const

Returns the string converted to an <tt>unsigned long</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0
if the conversion fails.

If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.

If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with
&quot;0&quot;, base 8 is used; otherwise, base 10 is used.

Example:

\code
    QString str = "FF";
    bool ok;

    ulong hex = str.toULong(&ok, 16);   // hex == 255, ok == true
    ulong dec = str.toULong(&ok, 10);   // dec == 0,   ok == false
\endcode

<b>See also </b>number().


*/


/*!
\fn qulonglong QString::toULongLong ( bool * ok = 0, int base = 10 ) const

Returns the string converted to an <tt>unsigned long long</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. 
Returns 0 if the conversion fails.

If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.

If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.

Example:

\code
    QString str = "FF";
    bool ok;

    quint64 hex = str.toULongLong(&ok, 16);    // hex == 255, ok == true
    quint64 dec = str.toULongLong(&ok, 10);    // dec == 0,   ok == false
\endcode

<b>See also </b>number() and toLongLong().


*/


/*!
\fn ushort QString::toUShort ( bool * ok = 0, int base = 10 ) const

Returns the string converted to an <tt>unsigned short</tt> using base <i>base</i>, which is 10 by default and must be between 2 and 36, or 0. Returns 0 
if the conversion fails.

If a conversion error occurs, *<i>ok</i> is set to false; otherwise *<i>ok</i> is set to true.

If <i>base</i> is 0, the C language convention is used: If the string begins with &quot;0x&quot;, base 16 is used; if the string begins with &quot;0&quot;, base 8 is used; otherwise, base 10 is used.

Example:

\code
    QString str = "FF";
    bool ok;

    ushort hex = str.toUShort(&ok, 16);     // hex == 255, ok == true
    ushort dec = str.toUShort(&ok, 10);     // dec == 0,   ok == false
\endcode

<b>See also </b>number() and toShort().

*/


/*!
\fn QString QString::toUpper () const

Returns an uppercase copy of the string.

\code
    QString str = "TeXt";
    str = str.toUpper();        // str == "TEXT"
\endcode

The case conversion will always happen in the 'C' locale. For locale dependent case folding use QLocale::toUpper()

<b>See also </b>toLower() and QLocale::toLower().


*/


/*!
\fn QByteArray QString::toUtf8 () const

Returns a UTF-8 representation of the string as a QByteArray.

UTF-8 is a Unicode codec and can represent all characters in a Unicode string like QString.

However, in the Unicode range, there are certain codepoints that are not considered characters. The Unicode standard reserves the last two codepoints in each Unicode Plane (U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, etc.), as well as 16 codepoints in the range U+FDD0..U+FDDF, inclusive, as non-characters. If any of those appear in the string, they may be discarded and will not appear in the UTF-8 representation, or they may be replaced by one or more replacement characters.

<b>See also </b>fromUtf8(), toAscii(), toLatin1(), toLocal8Bit(), and QTextCodec.


*/


/*!
\fn int QString::toWCharArray ( wchar_t * array ) const

Fills the <i>array</i> with the data contained in this QString object. The array is encoded in utf16 on platforms where wchar_t is 2 bytes wide (e.g. windows) and in ucs4 on platforms where wchar_t is 4 bytes wide (most Unix systems).

<i>array</i> has to be allocated by the caller and contain enough space to hold the complete string (allocating the array with the same length as the string is always sufficient).

returns the actual length of the string in <i>array</i>.

<b>Note:</b> This function does not append a null character to the array.

This function was introduced in Qt 4.2.

<b>See also </b>utf16(), toUcs4(), toAscii(), toLatin1(), toUtf8(), toLocal8Bit(), and toStdWString().


*/


/*!
\fn QString QString::trimmed () const

Returns a string that has whitespace removed from the start and the end.

Whitespace means any character for which QChar::isSpace() returns true. This includes the ASCII characters '\\t', '\\n', '\\v', '\\f', '\\r', and ' '.

Example:

\code
    QString str = "  lots\t of\nwhitespace\r\n ";
    str = str.trimmed();
    // str == "lots\t of\nwhitespace"
\endcode

Unlike simplified(), trimmed() leaves internal whitespace alone.

<b>See also </b>simplified().


*/


/*!
\fn void QString::truncate ( int position )

Truncates the string at the given <i>position</i> index.

If the specified <i>position</i> index is beyond the end of the string, nothing happens.

Example:

\code
    QString str = "Vladivostok";
    str.truncate(4);
    // str == "Vlad"
\endcode

If <i>position</i> is negative, it is equivalent to passing zero.

<b>See also </b>chop(), resize(), and left().


*/


/*!
\fn const QChar * QString::unicode () const

Returns a '\0'-terminated Unicode representation of the string. The result remains valid until the string is modified.

<b>See also </b>setUnicode() and utf16().


*/


/*!
\fn const ushort * QString::utf16 () const

Returns the QString as a '\0'-terminated array of unsigned shorts. The result remains valid until the string is modified.

The returned string is in host byte order.

<b>See also </b>setUtf16() and unicode().


*/


/*!
\fn QString & QString::vsprintf ( const char * cformat, va_list ap )

Equivalent method to sprintf(), but takes a va_list <i>ap</i> instead a list of variable arguments. See the sprintf() documentation for an explanation of <i>cformat</i>.

This method does not call the va_end macro, the caller is responsible to call va_end on <i>ap</i>.

<b>See also </b>sprintf().


*/


/*!
\fn bool operator!= ( const QString & s1, const QString &s2 ) const
\relates QString

Returns true if this string is not equal to string <i>other</i>; otherwise returns false.

The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().


*/


/*!
\fn bool QString::operator!= ( const QLatin1String & other ) const

This function overloads operator!=().


*/


/*!
\fn bool QString::operator!= ( const QByteArray & other ) const

This function overloads operator!=().

The <i>other</i> byte array is converted to a QString using the fromAscii() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn bool QString::operator!= ( const char * other ) const

This function overloads operator!=().

The <i>other</i> const char pointer is converted to a QString using the fromAscii() function.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to 
ensure that all user-visible strings go through QObject::tr(), for example.


*/



/*!
\fn QString &QString::operator=(const QString &other)

Appends the string <i>other</i> onto the end of this string and returns a reference to this string.

Example:

\code
    QString x = "free";
    QString y = "dom";
    x += y;
    // x == "freedom"
\endcode

This operation is typically very fast (constant time), because QString preallocates extra space at the 
end of the string data so it can grow without reallocating the entire string each time.

<b>See also </b>append() and prepend().


*/


/*!
\fn QString & QString::operator+= ( const QLatin1String & str )

This function overloads operator+=().

Appends the Latin-1 string <i>str</i> to this string.


*/


/*!
\fn QString & QString::operator+= ( const QByteArray & ba )

This function overloads operator+=().

Appends the byte array <i>ba</i> to this string. The byte array is converted to Unicode using the fromAscii() function. If any NUL characters ('\0') are embedded in the <i>ba</i> byte array, they will be included in the transformation.

You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::operator+= ( const char * str )

This function overloads operator+=().

Appends the string <i>str</i> to this string. The const char pointer is converted to Unicode using the fromAscii() function.

You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::operator+= ( const QStringRef & str )

This function overloads operator+=().

Appends the string section referenced by <i>str</i> to this string.


*/


/*!
\fn QString & QString::operator+= ( char ch )

This function overloads operator+=().

Appends the character <i>ch</i> to this string. The character is converted to Unicode using the fromAscii() function.

You can disable this function by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::operator+= ( QChar ch )

This function overloads operator+=().

Appends the character <i>ch</i> to the string.


*/


/*!
\fn bool operator< ( const QString & s1, const QString & s2 )
\relates QString

Returns true if this string is lexically less than string <i>other</i>; otherwise returns false.

The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings using the QString::localeAwareCompare() function.


*/


/*!
\fn bool QString::operator< ( const QLatin1String & other ) const

This function overloads operator&lt;().


*/


/*!
\fn bool operator< ( const QByteArray & other ) const

This function overloads operator&lt;().

The <i>other</i> byte array is converted to a QString using the fromAscii() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn bool QString::operator< ( const char * other ) const

This function overloads operator&lt;().

The <i>other</i> const char pointer is converted to a QString using the fromAscii() function.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn bool operator<= ( const QString & other ) const

Returns true if this string is lexically less than or equal to string <i>other</i>; otherwise returns false.

The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().


*/


/*!
\fn bool QString::operator<= ( const QLatin1String & other ) const

This function overloads operator&lt;=().


*/


/*!
\fn bool operator<= ( const QByteArray & other ) const

This function overloads operator&lt;=().

The <i>other</i> byte array is converted to a QString using the fromAscii() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn bool QString::operator<= ( const char * other ) const

This function overloads operator&lt;=().

The <i>other</i> const char pointer is converted to a QString using the fromAscii() function.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::operator= ( const QString & other )

Assigns <i>other</i> to this string and returns a reference to this string.


*/


/*!
\fn QString & QString::operator= ( const QLatin1String & str )

This function overloads operator=().

Assigns the Latin-1 string <i>str</i> to this string.


*/


/*!
\fn QString & QString::operator= ( const QByteArray & ba )

This function overloads operator=().

Assigns <i>ba</i> to this string. The byte array is converted to Unicode using the fromAscii() function. This function stops conversion at the first NUL character found, or the end of the <i>ba</i> byte array.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::operator= ( const char * str )

This function overloads operator=().

Assigns <i>str</i> to this string. The const char pointer is converted to Unicode using the fromAscii() function.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::operator= ( char ch )

This function overloads operator=().

Assigns character <i>ch</i> to this string. The character is converted to Unicode using the fromAscii() function.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QString & QString::operator= ( QChar ch )

This function overloads operator=().

Sets the string to contain the single character <i>ch</i>.


*/


/*!
\fn bool operator== ( const QString & other ) const

Returns true if string <i>other</i> is equal to this string; otherwise returns false.

The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().


*/


/*!
\fn bool QString::operator== ( const QLatin1String & other ) const

This function overloads operator==().


*/


/*!
\fn bool QString::operator== ( const QByteArray & other ) const

This function overloads operator==().

The <i>other</i> byte array is converted to a QString using the fromAscii() function. This function stops conversion at the first NUL character found, or the end of the byte array.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn bool QString::operator== ( const char * other ) const

This function overloads operator==().

The <i>other</i> const char pointer is converted to a QString using the fromAscii() function.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn bool operator> ( const QString & other ) const

Returns true if this string is lexically greater than string <i>other</i>; otherwise returns false.

The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().


*/


/*!
\fn bool QString::operator> ( const QLatin1String & other ) const

This function overloads operator&gt;().


*/


/*!
\fn bool operator> ( const QByteArray & other ) const

This function overloads operator&gt;().

The <i>other</i> byte array is converted to a QString using the fromAscii() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn bool QString::operator> ( const char * other ) const

This function overloads operator&gt;().

The <i>other</i> const char pointer is converted to a QString using the fromAscii() function.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn bool operator>= ( const QString & other ) const

Returns true if this string is lexically greater than or equal to string <i>other</i>; otherwise returns false.

The comparison is based exclusively on the numeric Unicode values of the characters and is very fast, but is not what a human would expect. Consider sorting user-interface strings with localeAwareCompare().


*/


/*!
\fn bool QString::operator>= ( const QLatin1String & other ) const

This function overloads operator&gt;=().


*/


/*!
\fn bool QString::operator>= ( const QByteArray & other ) const

This function overloads operator&gt;=().

The <i>other</i> byte array is converted to a QString using the fromAscii() function. If any NUL characters ('\0') are embedded in the byte array, they will be included in the transformation.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn bool QString::operator>= ( const char * other ) const

This function overloads operator>=().

The <i>other</i> const char pointer is converted to a QString using the fromAscii() function.

You can disable this operator by defining <tt>QT_NO_CAST_FROM_ASCII</tt> when you compile your applications. This can be useful if you want to ensure that all user-visible strings go through QObject::tr(), for example.


*/


/*!
\fn QCharRef QString::operator[] ( int position )

Returns the character at the specified <i>position</i> in the string as a modifiable reference.

Example:

\code
    QString str;

    if (str[0] == QChar('?')) {
        str[0] = QChar('_');
    }  
\endcode

The return value is of type QCharRef, a helper class for QString. When you get an object of type QCharRef, you can use it as if it were a QChar &. If you assign to it, the assignment will apply to the character in the QString from which you got the reference.

<b>See also </b>at().


*/


/*!
\fn const QChar QString::operator[] ( int position ) const

This function overloads operator[]().


*/


/*!
\fn QCharRef QString::operator[] ( uint position )

This function overloads operator[]().

Returns the character at the specified <i>position</i> in the string as a modifiable reference. Equivalent to <tt>at(position)</tt>.


*/


/*!
\fn const QChar QString::operator[] ( uint position ) const

This function overloads operator[]().


*/


/*!
\typedef QString::ConstIterator

Qt-style synonym for QString::const_iterator.


*/


/*!
\typedef QString::Iterator

Qt-style synonym for QString::iterator.


*/



/*!
\typedef QString::const_iterator

The QString::const_iterator typedef provides an STL-style const iterator for QString.

<b>See also </b>QString::iterator.


*/


/*!
\typedef QString::const_reference

The QString::const_reference typedef provides an STL-style const reference for QString.


*/


/*!
\typedef QString::iterator

The QString::iterator typedef provides an STL-style non-const iterator for QString.

<b>See also </b>QString::const_iterator.


*/


/*!
\typedef QString::reference

The QString::const_reference typedef provides an STL-style reference for QString.


*/


/*!
\typedef QString::value_type

The QString::const_reference typedef provides an STL-style value type for QString.


*/

