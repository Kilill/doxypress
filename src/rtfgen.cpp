/*************************************************************************
 *
 * Copyright (C) 1997-2014 by Dimitri van Heesch. 
 * Copyright (C) 1997-2014 by Parker Waechter 
 * Copyright (C) 2014-2015 Barbara Geller & Ansel Sermersheim 
 * All rights reserved.    
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation under the terms of the GNU General Public License version 2
 * is hereby granted. No representations are made about the suitability of
 * this software for any purpose. It is provided "as is" without express or
 * implied warranty. See the GNU General Public License for more details.
 *
 * Documents produced by Doxygen are derivative works derived from the
 * input used in their production; they are not affected by this license.
 *
*************************************************************************/

#include <QDir>
#include <QRegExp>
#include <QTextCodec>
#include <QTextStream>

#include <stdlib.h>

#include <rtfgen.h>
#include <config.h>
#include <message.h>
#include <doxygen.h>

#include <classlist.h>
#include <diagram.h>
#include <language.h>
#include <dirdef.h>
#include <docparser.h>
#include <dot.h>
#include <doxy_build_info.h>
#include <filename.h>
#include <groupdef.h>
#include <namespacedef.h>
#include <pagedef.h>
#include <rtfstyle.h>
#include <rtfdocvisitor.h>
#include <portable.h>
#include <util.h>

#include <doxy_globals.h>

#define DBG_RTF(x)

static QByteArray dateToRTFDateString()
{
   const QDateTime &d = QDateTime::currentDateTime();

   QByteArray result;

   result = QString("\\yr%1\\mo%2\\dy%3\\hr%4\\min%5\\sec%6").
                  arg(d.date().year()).arg(d.date().month()).arg(d.date().day()).
                  arg(d.time().hour()).arg(d.time().minute()).arg(d.time().second()).toUtf8();

   return result;
}

RTFGenerator::RTFGenerator() : OutputGenerator()
{
   dir = Config_getString("RTF_OUTPUT");
   col = 0;

   //insideTabbing=false;
   m_listLevel = 0;
   m_bstartedBody = false;
   m_omitParagraph = false;
   m_numCols = 0;
}

RTFGenerator::~RTFGenerator()
{
}

//void RTFGenerator::append(const OutputGenerator *g)
//{
//  t << g->getContents();
//  col+=((RTFGenerator *)g)->col;
//  //insideTabbing=insideTabbing || ((RTFGenerator *)g)->insideTabbing;
//  m_listLevel=((RTFGenerator *)g)->m_listLevel;
//  m_omitParagraph=((RTFGenerator *)g)->m_omitParagraph;
//  //printf("RTFGenerator::append(%s) insideTabbing=%s\n", g->getContents().data(),
//  //    insideTabbing ? "true" : "false" );
//}

//OutputGenerator *RTFGenerator::copy()
//{
//  RTFGenerator *result = new RTFGenerator;
//  //result->insideTabbing=insideTabbing;
//  result->m_listLevel=m_listLevel;
//  result->m_omitParagraph=m_omitParagraph;
//  return result;
//}

void RTFGenerator::writeStyleSheetFile(QFile &file)
{
   QTextStream t_stream(&file);

   t_stream << "# Generated by CS Doxygen " << versionString << "\n\n";
   t_stream << "# This file describes styles used for generating RTF output.\n";
   t_stream << "# All text after a hash (#) is considered a comment and will be ignored.\n";
   t_stream << "# Remove a hash to activate a line.\n\n";
   
   for (int i = 0 ; rtf_Style_Default[i].reference != 0 ; i++ ) {
      t_stream << "# " << rtf_Style_Default[i].name << " = "
        << rtf_Style_Default[i].reference
        << rtf_Style_Default[i].definition << endl;
   }
}

void RTFGenerator::writeExtensionsFile(QFile &file)
{
   QTextStream t_stream(&file);

   t_stream << "# Generated by CS Doxygen " << versionString << "\n\n";
   t_stream << "# This file describes extensions used for generating RTF output.\n";
   t_stream << "# All text after a hash (#) is considered a comment and will be ignored.\n";
   t_stream << "# Remove a hash to activate a line.\n\n";

   t_stream << "# Overrides the project title.\n";

   t_stream << "#Title           = \n\n";

   t_stream << "# Name of the company that produced this document.\n";
   t_stream << "#Company         = \n\n";

   t_stream << "# Filename of a company or project logo.\n";
   t_stream << "#LogoFilename    = \n\n";

   t_stream << "# Author of the document.\n";
   t_stream << "#Author          = \n\n";

   t_stream << "# Type of document (e.g. Design Specification, User Manual, etc.).\n";
   t_stream << "#DocumentType    = \n\n";

   t_stream << "# Document tracking number.\n";
   t_stream << "#DocumentId      = \n\n";

   t_stream << "# Name of the author's manager.\n";
   t_stream << "# This field is not displayed in the document itself, but it is \n";
   t_stream << "# available in the information block of the rtf file.  In Microsoft \n";
   t_stream << "# Word, it is available under File:Properties.\n";
   t_stream << "#Manager         = \n\n";

   t_stream << "# Subject of the document.\n";
   t_stream << "# This field is not displayed in the document itself, but it is \n";
   t_stream << "# available in the information block of the rtf file.  In Microsoft \n";
   t_stream << "# Word, it is available under File:Properties.\n";
   t_stream << "#Subject         = \n\n";

   t_stream << "# Comments regarding the document.\n";
   t_stream << "# This field is not displayed in the document itself, but it is \n";
   t_stream << "# available in the information block of the rtf file.  In Microsoft \n";
   t_stream << "# Word, it is available under File:Properties.\n";
   t_stream << "#Comments        = \n\n";

   t_stream << "# Keywords associated with the document.\n";
   t_stream << "# This field is not displayed in the document itself, but it is \n";
   t_stream << "# available in the information block of the rtf file.  In Microsoft \n";
   t_stream << "# Word, it is available under File:Properties.\n";
   t_stream << "#Keywords        = \n\n";
}

void RTFGenerator::init()
{
   QByteArray dir = Config_getString("RTF_OUTPUT");
   QDir d(dir);

   if (! d.exists() && !d.mkdir(dir)) {
      err("Could not create output directory %s\n", dir.data());
      exit(1);
   }
 
   // first duplicate strings of rtf_Style_Default
   const struct Rtf_Style_Default *def = rtf_Style_Default;

   while (def->reference != 0) {
      if (def->definition == 0) {
         err("Internal: rtf_Style_Default[%s] has no definition.\n", def->name);
      }

      StyleData styleData = StyleData(def->reference, def->definition);
      rtf_Style.insert(def->name, styleData);
      def++;
   }

   // overwrite some (or all) definitions from file
   QByteArray &rtfStyleSheetFile = Config_getString("RTF_STYLESHEET_FILE");
   if (!rtfStyleSheetFile.isEmpty()) {
      loadStylesheet(rtfStyleSheetFile, rtf_Style);
   }

   // If user has defined an extension file, load its contents.
   QByteArray &rtfExtensionsFile = Config_getString("RTF_EXTENSIONS_FILE");
   if (!rtfExtensionsFile.isEmpty()) {
      loadExtensions(rtfExtensionsFile);
   }

   createSubDirs(d);
}

static QByteArray makeIndexName(const char *s, int i)
{
   QByteArray result = s;
   result += (char)(i + '0');
   return result;
}

void RTFGenerator::beginRTFDocument()
{
   /* all the included RTF files should begin with the
    * same header
    */
   m_textStream << "{\\rtf1\\ansi\\ansicpg" << theTranslator->trRTFansicp();
   m_textStream << "\\uc1 \\deff0\\deflang1033\\deflangfe1033\n";

   DBG_RTF(m_textStream << "{\\comment Beginning font list}\n")
   m_textStream << "{\\fonttbl ";
   m_textStream << "{\\f0\\froman\\fcharset" << theTranslator->trRTFCharSet();
   m_textStream << "\\fprq2{\\*\\panose 02020603050405020304}Times New Roman;}\n";
   m_textStream << "{\\f1\\fswiss\\fcharset" << theTranslator->trRTFCharSet();
   m_textStream << "\\fprq2{\\*\\panose 020b0604020202020204}Arial;}\n";
   m_textStream << "{\\f2\\fmodern\\fcharset" << theTranslator->trRTFCharSet();
   m_textStream << "\\fprq1{\\*\\panose 02070309020205020404}Courier New;}\n";
   m_textStream << "{\\f3\\froman\\fcharset2\\fprq2{\\*\\panose 05050102010706020507}Symbol;}\n";
   m_textStream << "}\n";

   DBG_RTF(m_textStream << "{\\comment begin colors}\n")
   m_textStream << "{\\colortbl;";
   m_textStream << "\\red0\\green0\\blue0;";
   m_textStream << "\\red0\\green0\\blue255;";
   m_textStream << "\\red0\\green255\\blue255;";
   m_textStream << "\\red0\\green255\\blue0;";
   m_textStream << "\\red255\\green0\\blue255;";
   m_textStream << "\\red255\\green0\\blue0;";
   m_textStream << "\\red255\\green255\\blue0;";
   m_textStream << "\\red255\\green255\\blue255;";
   m_textStream << "\\red0\\green0\\blue128;";
   m_textStream << "\\red0\\green128\\blue128;";
   m_textStream << "\\red0\\green128\\blue0;";
   m_textStream << "\\red128\\green0\\blue128;";
   m_textStream << "\\red128\\green0\\blue0;";
   m_textStream << "\\red128\\green128\\blue0;";
   m_textStream << "\\red128\\green128\\blue128;";
   m_textStream << "\\red192\\green192\\blue192;}" << endl;

   DBG_RTF(m_textStream << "{\\comment Beginning style list}\n")
   m_textStream << "{\\stylesheet\n";
   m_textStream << "{\\widctlpar\\adjustright \\fs20\\cgrid \\snext0 Normal;}\n";

   // sort styles ascending by \s-number via an intermediate QArray
   QVector<const StyleData *> array(128);
   array.fill(0);
  
   for (auto iter = rtf_Style.begin(); iter != rtf_Style.end(); ++iter)  {      
      unsigned index = iter->index;
      unsigned size  = array.size();

      if (index >= size) {
         // +1 to add at least one element, then align up to multiple of 8
         array.resize((index + 1 + 7) & ~7);
         array.fill(0, size);
         assert(index < array.size());
      }

      if (array.at(index) != 0) {
         QString key(iter.key());
         msg("Style '%s' redefines \\s%d.\n", qPrintable(key), index);
      }

      array[index] = &iter.value();
   }

   // write array elements
   unsigned size = array.size();

   for (unsigned i = 0; i < size; i++) {
      const StyleData *style = array.at(i);

      if (style != 0) {
         m_textStream << "{" << style->reference << style->definition << ";}\n";
      }
   }

   m_textStream << "}" << endl;

   // this comment is needed for postprocessing
   m_textStream << "{\\comment begin body}" << endl;

}

void RTFGenerator::beginRTFChapter()
{
   m_textStream << "\n";
   DBG_RTF(m_textStream << "{\\comment BeginRTFChapter}\n")
   m_textStream << rtf_Style_Reset;

   // if we are compact, no extra page breaks

   if (Config_getBool("COMPACT_RTF")) {    
      m_textStream << "\\sect\\sbknone\n";
      rtfwriteRuler_thick();

   } else {
      m_textStream << "\\sect\\sbkpage\n";
   }

   m_textStream << rtf_Style["Heading1"].reference << "\n";
}

void RTFGenerator::beginRTFSection()
{
   m_textStream << "\n";
   DBG_RTF(m_textStream << "{\\comment BeginRTFSection}\n")
   m_textStream << rtf_Style_Reset;

   // if we are compact, no extra page breaks

   if (Config_getBool("COMPACT_RTF")) {
      
      m_textStream << "\\sect\\sbknone\n";
      rtfwriteRuler_emboss();

   } else {
      m_textStream << "\\sect\\sbkpage\n";

   }

   m_textStream << rtf_Style["Heading2"].reference << "\n";
}

void RTFGenerator::startFile(const char *name, const char *, const char *)
{
   //setEncoding(QByteArray().sprintf("CP%s",theTranslator->trRTFansicp()));
   QByteArray fileName = name;
   relPath = relativePathToRoot(fileName);

   if (fileName.right(4) != ".rtf" ) {
      fileName += ".rtf";
   }
   startPlainFile(fileName);
   beginRTFDocument();
}

void RTFGenerator::endFile()
{
   DBG_RTF(m_textStream << "{\\comment endFile}\n")
   m_textStream << "}";

   endPlainFile();
}

void RTFGenerator::startProjectNumber()
{
   DBG_RTF(m_textStream << "{\\comment startProjectNumber }" << endl)
   m_textStream << " ";
}

void RTFGenerator::endProjectNumber()
{
   DBG_RTF(t << "{\\comment endProjectNumber }" << endl)
}

void RTFGenerator::startIndexSection(IndexSections is)
{  
   m_listLevel = 0;

   switch (is) {
      case isTitlePageStart:
         // basic RTFstart
         // get readyfor author etc

         m_textStream << "{\\info \n";
         m_textStream << "{\\title {\\comment ";
         break;

      case isTitlePageAuthor:
         m_textStream << "}\n";

         if (! rtf_subject.isEmpty()) {
            m_textStream << "{\\subject "  << rtf_subject      << "}\n";
         }

         if (! rtf_comments.isEmpty()) {
            m_textStream << "{\\comment "  << rtf_comments     << "}\n";
         }

         if (! rtf_company.isEmpty()) {
            m_textStream << "{\\company "  << rtf_company      << "}\n";
         }

         if (! rtf_author.isEmpty()) {
            m_textStream << "{\\author "   << rtf_author       << "}\n";
         }

         if (! rtf_manager.isEmpty()) {
            m_textStream << "{\\manager "  << rtf_manager      << "}\n";
         }

         if (! rtf_documentType.isEmpty()) {
            m_textStream << "{\\category " << rtf_documentType << "}\n";
         }

         if (! rtf_keywords.isEmpty()) {
            m_textStream << "{\\keywords " << rtf_keywords     << "}\n";
         }

         m_textStream << "{\\comment ";
         break;

      case isMainPage:
         //Introduction
         beginRTFChapter();
         break;

      //case isPackageIndex:
      //  //Package Index
      //  beginRTFChapter();
      //  break;

      case isModuleIndex:
         //Module Index
         beginRTFChapter();
         break;
      case isDirIndex:
         //Directory Index
         beginRTFChapter();
         break;
      case isNamespaceIndex:
         //Namespace Index
         beginRTFChapter();
         break;
      case isClassHierarchyIndex:
         //Hierarchical Index
         DBG_RTF(m_textStream << "{\\comment start classhierarchy}\n")
         beginRTFChapter();
         break;
      case isCompoundIndex:
         //Annotated Compound Index
         beginRTFChapter();
         break;
      case isFileIndex:
         //Annotated File Index
         beginRTFChapter();
         break;

      case isPageIndex:
         //Related Page Index
         beginRTFChapter();
         break;

      case isModuleDocumentation:
       {
         //Module Documentation       
         bool found = false;
        
         for (auto gd : *Doxygen::groupSDict)  {

            if (found) { 
               break;
            }


            if (!gd->isReference()) {
               beginRTFChapter();
               found = true;
            }
         }
      }
      break;

      case isDirDocumentation:   {
         //Directory Documentation       
         bool found = false;
      
         for (auto dd : Doxygen::directories)  {

            if (found) { 
               break;
            }

            if (dd->isLinkableInProject()) {
               beginRTFChapter();
               found = true;
            }
         }
      }
      break;

      case isNamespaceDocumentation: {
         // Namespace Documentation       
         bool found = false;
       
         for (auto nd : *Doxygen::namespaceSDict)  {

            if (found) { 
               break;
            }

            if (nd->isLinkableInProject()) {
               beginRTFChapter();
               found = true;
            }
         }
      }
      break;

      case isClassDocumentation: {
         //Compound Documentation          
         bool found = false;
       
         for (auto cd : *Doxygen::classSDict)  {

            if (found) { 
               break;
            }

            if (cd->isLinkableInProject() && cd->templateMaster() == 0 && !cd->isEmbeddedInOuterScope()) {
               beginRTFChapter();
               found = true;
            }
         }
      }

      break;
      case isFileDocumentation: {
         //File Documentation
         bool isFirst = true;
       
         for (auto fn : *Doxygen::inputNameList)  {
           
            for (auto fd : *fn)  {
               if (fd->isLinkableInProject()) {
                  if (isFirst) {
                     beginRTFChapter();
                     isFirst = false;
                     break;
                  }
               }
            }
         }
      }
      break;
      case isExampleDocumentation: {
         //Example Documentation
         beginRTFChapter();
      }
      break;

      case isPageDocumentation: {
         //Page Documentation
         beginRTFChapter();
      }
      break;

      case isPageDocumentation2: {
         m_textStream  << "{\\tc \\v ";
      }
      break;

      case isEndIndex:
         break;
   }
}

void RTFGenerator::endIndexSection(IndexSections indexSec)
{
   bool fortranOpt = Config_getBool("OPTIMIZE_FOR_FORTRAN");
 
   switch (indexSec) {
      case isTitlePageStart:

         if (! rtf_title.isEmpty())
            // User has overridden document title in extensions file
         {
            m_textStream << "}" << rtf_title;
         } else {
            m_textStream << "}" << Config_getString("PROJECT_NAME");
         }
         break;

      case isTitlePageAuthor: {
         m_textStream << "Doxgyen. }\n";
         m_textStream << "{\\creatim " << dateToRTFDateString() << "}\n}";

         DBG_RTF(m_textStream << "{\\comment end of infoblock}\n");
         // setup for this section
         m_textStream << rtf_Style_Reset << "\n";
         m_textStream << "\\sectd\\pgnlcrm\n";
         m_textStream << "{\\footer " << rtf_Style["Footer"].reference << "{\\chpgn}}\n";

         // the title entry
         DBG_RTF(t << "{\\comment begin title page}\n")

         m_textStream  << rtf_Style_Reset << rtf_Style["SubTitle"].reference << endl; // set to title style

         m_textStream  << "\\vertalc\\qc\\par\\par\\par\\par\\par\\par\\par\n";
         if (! rtf_logoFilename.isEmpty()) {
            m_textStream  << "{\\field\\flddirty {\\*\\fldinst INCLUDEPICTURE \"" << rtf_logoFilename;
            m_textStream  << "\" \\\\d \\\\*MERGEFORMAT} {\\fldrslt IMAGE }}\\par\\par\n";
         }

         if (! rtf_company.isEmpty()) {
            m_textStream  << rtf_company << "\\par\\par\n";
         }

         m_textStream  << rtf_Style_Reset << rtf_Style["Title"].reference << endl; // set to title style
         m_textStream  << "{\\field\\fldedit {\\*\\fldinst TITLE \\\\*MERGEFORMAT}{\\fldrslt TITLE}}\\par" << endl;

         m_textStream  << rtf_Style_Reset << rtf_Style["SubTitle"].reference << endl; // set to title style
         m_textStream  << "\\par\n";

         if (! rtf_documentType.isEmpty()) {
            m_textStream  << rtf_documentType << "\\par\n";
         }

         if (! rtf_documentId.isEmpty()) {
            m_textStream  << rtf_documentId << "\\par\n";
         }

         m_textStream  << "\\par\\par\\par\\par\\par\\par\\par\\par\\par\\par\\par\\par\n";

         m_textStream  << rtf_Style_Reset << rtf_Style["SubTitle"].reference << endl; // set to subtitle style
         m_textStream  << "{\\field\\fldedit {\\*\\fldinst AUTHOR \\\\*MERGEFORMAT}{\\fldrslt AUTHOR}}\\par" << endl;
         m_textStream  << "Version " << Config_getString("PROJECT_NUMBER") << "\\par";

         m_textStream  << "{\\field\\fldedit {\\*\\fldinst CREATEDATE \\\\*MERGEFORMAT}"
           "{\\fldrslt CREATEDATE}}\\par" << endl;
         m_textStream  << "\\page\\page";

         DBG_RTF(m_textStream  << "{\\comment End title page}" << endl)

         // table of contents section
         DBG_RTF(t << "{\\comment Table of contents}\n")
         m_textStream  << "\\vertalt\n";
         m_textStream  << rtf_Style_Reset << endl;
         m_textStream  << rtf_Style["Heading1"].reference;
         m_textStream  << theTranslator->trRTFTableOfContents() << "\\par" << endl;
         m_textStream  << rtf_Style_Reset << "\\par" << endl;
         m_textStream  << "{\\field\\fldedit {\\*\\fldinst TOC \\\\f \\\\*MERGEFORMAT}{\\fldrslt Table of contents}}\\par\n";
         m_textStream  << rtf_Style_Reset << endl;
      }
      break;
      case isMainPage:
         m_textStream  << "\\par " << rtf_Style_Reset << endl;

         if (!Doxygen::mainPage || Doxygen::mainPage->title().isEmpty()) {
            m_textStream  << "{\\tc \\v " << theTranslator->trMainPage() << "}" << endl;
         } else {
            m_textStream  << "{\\tc \\v " << substitute(Doxygen::mainPage->title(), "%", "") << "}" << endl;
         }
         m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
         //if (Config_getBool("GENERATE_TREEVIEW")) t << "main"; else t << "index";
         m_textStream  << "index";
         m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
         break;

      //case isPackageIndex:
      //  t << "\\par " << rtf_Style_Reset << endl;
      //  t << "{\\tc \\v " << theTranslator->trPackageList() << "}"<< endl;
      //  t << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"packages.rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
      //  break;
      case isModuleIndex:
         m_textStream  << "\\par " << rtf_Style_Reset << endl;
         m_textStream  << "{\\tc \\v " << theTranslator->trModuleIndex() << "}" << endl;
         m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"modules.rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
         break;
      case isDirIndex:
         m_textStream  << "\\par " << rtf_Style_Reset << endl;
         m_textStream  << "{\\tc \\v " << theTranslator->trDirIndex() << "}" << endl;
         m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"dirs.rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
         break;
      case isNamespaceIndex:
         m_textStream  << "\\par " << rtf_Style_Reset << endl;
         if (fortranOpt) {
            m_textStream  << "{\\tc \\v " << theTranslator->trModulesIndex() << "}" << endl;
         } else {
            m_textStream  << "{\\tc \\v " << theTranslator->trNamespaceIndex() << "}" << endl;
         }

         m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"namespaces.rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
         break;
      case isClassHierarchyIndex:
         m_textStream  << "\\par " << rtf_Style_Reset << endl;
         m_textStream  << "{\\tc \\v " << theTranslator->trHierarchicalIndex() << "}" << endl;
         m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"hierarchy.rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
         break;
      case isCompoundIndex:
         m_textStream  << "\\par " << rtf_Style_Reset << endl;
         if (fortranOpt) {
            m_textStream  << "{\\tc \\v " << theTranslator->trCompoundIndexFortran() << "}" << endl;
         
         } else {
            m_textStream  << "{\\tc \\v " << theTranslator->trCompoundIndex() << "}" << endl;
         }
         m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"annotated.rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
         break;
      case isFileIndex:
         m_textStream  << "\\par " << rtf_Style_Reset << endl;
         m_textStream  << "{\\tc \\v " << theTranslator->trFileIndex() << "}" << endl;
         m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"files.rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
         break;
      case isPageIndex:
         m_textStream  << "\\par " << rtf_Style_Reset << endl;
         m_textStream  << "{\\tc \\v " << theTranslator->trPageIndex() << "}" << endl;
         m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"pages.rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
         break;

      case isModuleDocumentation: {         
         m_textStream  << "{\\tc \\v " << theTranslator->trModuleDocumentation() << "}" << endl;
      
         for (auto gd :*Doxygen::groupSDict) {
            if (!gd->isReference()) {
               m_textStream  << "\\par " << rtf_Style_Reset << endl;
               m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
               m_textStream  << gd->getOutputFileBase();
               m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
            }
         }
      }

      break;

      case isDirDocumentation:
       {    
         m_textStream  << "{\\tc \\v " << theTranslator->trDirDocumentation() << "}" << endl;

         for (auto dd :Doxygen::directories) {
            if (dd->isLinkableInProject()) {
               m_textStream  << "\\par " << rtf_Style_Reset << endl;
               m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
               m_textStream  << dd->getOutputFileBase();
               m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
            }
         }
      }
      break;

      case isNamespaceDocumentation: {       
         bool found = false;

         auto iter = Doxygen::namespaceSDict->begin();
        
         for (auto nd :*Doxygen::namespaceSDict) {
            if (found) {
               break;
            }

            if (nd->isLinkableInProject()) {
               m_textStream  << "\\par " << rtf_Style_Reset << endl;
               m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
               m_textStream  << nd->getOutputFileBase();
               m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
               found = true;
            }

            ++iter;
         }

         while (iter !=  Doxygen::namespaceSDict->end()) {

            if ((*iter)->isLinkableInProject()) {
               m_textStream  << "\\par " << rtf_Style_Reset << endl;
               beginRTFSection();

               m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
               m_textStream  << (*iter)->getOutputFileBase();
               m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
            }

            ++iter;
         }
      }
      break;

      case isClassDocumentation: {        
         bool found = false;

         if (fortranOpt) {
            m_textStream  << "{\\tc \\v " << theTranslator->trTypeDocumentation() << "}" << endl;
         } else {
            m_textStream  << "{\\tc \\v " << theTranslator->trClassDocumentation() << "}" << endl;
         }
        
         for (auto cd :*Doxygen::classSDict) {
            if (found) {
               break;
            }

            if (cd->isLinkableInProject() && cd->templateMaster() == 0 && !cd->isEmbeddedInOuterScope() ) {
               m_textStream  << "\\par " << rtf_Style_Reset << endl;
               m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
               m_textStream  << cd->getOutputFileBase();
               m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
               found = true;
            }
         }

         for (auto cd :*Doxygen::classSDict) {          
            if (cd->isLinkableInProject() && cd->templateMaster() == 0 && !cd->isEmbeddedInOuterScope() ) {
               m_textStream  << "\\par " << rtf_Style_Reset << endl;
               beginRTFSection();
               m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
               m_textStream  << cd->getOutputFileBase();
               m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
            }
         }
      }
      break;

      case isFileDocumentation: {
         bool isFirst = true;

         m_textStream  << "{\\tc \\v " << theTranslator->trFileDocumentation() << "}" << endl;
       
         for (auto fn :*Doxygen::inputNameList) {  
            for (auto fd :*fn) {  
               if (fd->isLinkableInProject()) {
                  if (isFirst) {
                     m_textStream  << "\\par " << rtf_Style_Reset << endl;
                     m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
                     m_textStream  << fd->getOutputFileBase();
                     m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
                     isFirst = false;
                  } else {
                     m_textStream  << "\\par " << rtf_Style_Reset << endl;
                     beginRTFSection();
                     m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
                     m_textStream  << fd->getOutputFileBase();
                     m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
                  }
               }
            }
         }
      }
      break;

      case isExampleDocumentation: {
         //t << "}\n";
         m_textStream  << "{\\tc \\v " << theTranslator->trExampleDocumentation() << "}" << endl;
      
         auto iter1 = Doxygen::exampleSDict->begin();

         if (iter1 != Doxygen::exampleSDict->end()) {
            m_textStream  << "\\par " << rtf_Style_Reset << endl;

            m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
            m_textStream  << (*iter1)->getOutputFileBase();
            m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
       
            ++iter1;  
   
            for (auto iter2 = iter1; iter2 != Doxygen::exampleSDict->end(); ++iter2) {  
   
               m_textStream  << "\\par " << rtf_Style_Reset << endl;
               beginRTFSection();
   
               m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
               m_textStream  << (*iter2)->getOutputFileBase();
               m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
            }

         }
      }
      break;

      case isPageDocumentation: {
         //#error "fix me in the same way as the latex index..."
         //t << "{\\tc \\v " << theTranslator->trPageDocumentation() << "}"<< endl;
         //t << "}"<< endl;
         //PageSDict::Iterator pdi(*Doxygen::pageSDict);
         //PageDef *pd=pdi.toFirst();
         //bool first=true;
         //for (pdi.toFirst();(pd=pdi.current());++pdi)
         //{
         //  if (!pd->getGroupDef() && !pd->isReference())
         //  {
         //    if (first) t << "\\par " << rtf_Style_Reset << endl;
         //    t << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
         //    t << pd->getOutputFileBase();
         //    t << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
         //    first=false;
         //  }
         //}
      }
      break;
      case isPageDocumentation2: {
         m_textStream  << "}";
         m_textStream  << "\\par " << rtf_Style_Reset << endl;
      }
      break;
      case isEndIndex:
         beginRTFChapter();
         m_textStream  << rtf_Style["Heading1"].reference;
         m_textStream  << theTranslator->trRTFGeneralIndex() << "\\par " << endl;
         m_textStream  << rtf_Style_Reset << endl;
         m_textStream  << "{\\tc \\v " << theTranslator->trRTFGeneralIndex() << "}" << endl;
         m_textStream  << "{\\field\\fldedit {\\*\\fldinst INDEX \\\\c2 \\\\*MERGEFORMAT}{\\fldrslt INDEX}}\n";

         break;
   }
}

void RTFGenerator::writePageLink(const char *name, bool first)
{
   if (first) {
      m_textStream  << "\\par " << rtf_Style_Reset << endl;
   }

   m_textStream  << "{\\field\\fldedit{\\*\\fldinst INCLUDETEXT \"";
   m_textStream  << name;
   m_textStream  << ".rtf\" \\\\*MERGEFORMAT}{\\fldrslt includedstuff}}\n";
}

void RTFGenerator::lastIndexPage()
{
   DBG_RTF(t << "{\\comment Beginning Body of RTF Document}\n")
   // end page and setup for rest of document
   m_textStream  << "\\sect \\sbkpage \\pgndec \\pgnrestart\n";
   m_textStream  << "\\sect \\sectd \\sbknone\n";

   // set new footer with arabic numbers
   m_textStream  << "{\\footer " << rtf_Style["Footer"].reference << "{\\chpgn}}\n";  
}

void RTFGenerator::writeStyleInfo(int)
{
}

void RTFGenerator::lineBreak(const QByteArray &)
{
   DBG_RTF(t << "{\\comment (lineBreak)}"    << endl)
   m_textStream  << "\\par" << endl;
   m_omitParagraph = true;
}

void RTFGenerator::writeString(const char *text)
{
   m_textStream  << text;
}

void RTFGenerator::startIndexList()
{
   DBG_RTF(m_textStream  << "{\\comment (startIndexList)}" << endl)
   m_textStream  << "{" << endl;
   m_textStream  << "\\par" << endl;
   incrementIndentLevel();
   m_textStream  << rtf_Style_Reset << rtf_LCList_DepthStyle() << endl;
   m_omitParagraph = true;
}

void RTFGenerator::endIndexList()
{
   DBG_RTF(t << "{\\comment (endIndexList)}" << endl)
   if (!m_omitParagraph) {
      m_textStream  << "\\par";
      m_omitParagraph = true;
   }
   m_textStream  << "}";
   decrementIndentLevel();
}

/*! start bullet list */
void RTFGenerator::startItemList()
{
   newParagraph();
   DBG_RTF(m_textStream << "{\\comment (startItemList level=" << m_listLevel << ") }" << endl)
   m_textStream << "{";
   incrementIndentLevel();
   rtf_listItemInfo[m_listLevel].isEnum = false;
}

/*! end bullet list */
void RTFGenerator::endItemList()
{
   newParagraph();
   DBG_RTF(m_textStream << "{\\comment (endItemList level=" << m_listLevel << ")}" << endl)
   m_textStream << "}";
   decrementIndentLevel();
   m_omitParagraph = true;
}

///*! start enumeration list */
//void RTFGenerator::startEnumList()  // starts an enumeration list
//{
//  DBG_RTF(m_textStream << "{\\comment (startEnumList)}" << endl)
//  m_textStream << "{" << endl;
//  incrementIndentLevel();
//  rtf_listItemInfo[m_listLevel].isEnum = true;
//  rtf_listItemInfo[m_listLevel].number = 1;
//}
//
///*! end enumeration list */
//void RTFGenerator::endEnumList()
//{
//  newParagraph();
//  DBG_RTF(m_textStream << "{\\comment (endEnumList)}" << endl)
//  m_textStream << "}";
//  decrementIndentLevel();
//  m_omitParagraph = true;
//}

/*! write bullet or enum item */
void RTFGenerator::startItemListItem()
{
   DBG_RTF(m_textStream << "{\\comment (startItemListItem)}" << endl)
   newParagraph();
   m_textStream << rtf_Style_Reset;
   if (rtf_listItemInfo[m_listLevel].isEnum) {
      m_textStream << rtf_EList_DepthStyle() << endl;
      m_textStream << rtf_listItemInfo[m_listLevel].number << ".\\tab ";
      rtf_listItemInfo[m_listLevel].number++;
   } else {
      m_textStream << rtf_BList_DepthStyle() << endl;
   }
   m_omitParagraph = true;
}

void RTFGenerator::endItemListItem()
{
   DBG_RTF(m_textStream << "{\\comment (endItemListItem)}" << endl)
}

void RTFGenerator::startIndexItem(const QByteArray &, const QByteArray &)
{
   DBG_RTF(m_textStream << "{\\comment (startIndexItem)}" << endl)

   if (! m_omitParagraph) {
      m_textStream << "\\par" << endl;
      m_omitParagraph = true;
   }
}

void RTFGenerator::endIndexItem(const QByteArray &ref, const QByteArray &fn)
{
   DBG_RTF(m_textStream << "{\\comment (endIndexItem)}" << endl)

   if (ref.isEmpty() && ! fn.isEmpty()) {
      m_textStream << "\\tab ";
      writeRTFReference(fn);
      m_textStream << endl;

   } else {
      m_textStream << endl;
   }

   m_omitParagraph = true;
}

//void RTFGenerator::writeIndexFileItem(const char *,const char *text)
//{
//  m_textStream << "\\item\\contentsline{section}{";
//  docify(text);
//  m_textStream << "}{\\pageref{" << text << "}}" << endl;
//}

void RTFGenerator::startHtmlLink(const QByteArray &url)
{

   if (Config_getBool("RTF_HYPERLINKS")) {
      m_textStream << "{\\field {\\*\\fldinst { HYPERLINK \"";
      m_textStream << url;
      m_textStream << "\" }{}";
      m_textStream << "}{\\fldrslt {\\cs37\\ul\\cf2 ";

   } else {
      startTypewriter();
   }
}

void RTFGenerator::endHtmlLink()
{
   if (Config_getBool("RTF_HYPERLINKS")) {
      m_textStream << "}}}" << endl;
   } else {
      endTypewriter();
   }
}

//void RTFGenerator::writeMailLink(const char *url)
//{
//  startTypewriter();
//  docify(url);
//  endTypewriter();
//}

void RTFGenerator::writeStartAnnoItem(const char *, const QByteArray &f, const QByteArray &path, const char *name)
{
   DBG_RTF(m_textStream << "{\\comment (writeStartAnnoItem)}" << endl)
   m_textStream << "{\\b ";

   if (! path.isEmpty()) {
      docify(path);
   }

   if (! f.isEmpty() && Config_getBool("RTF_HYPERLINKS")) {
      m_textStream << "{\\field {\\*\\fldinst { HYPERLINK  \\\\l \"";
      m_textStream << rtfFormatBmkStr(f);
      m_textStream << "\" }{}";
      m_textStream << "}{\\fldrslt {\\cs37\\ul\\cf2 ";

      docify(name);

      m_textStream << "}}}" << endl;

   } else {
      docify(name);
   }

   m_textStream << "} ";
}

void RTFGenerator::writeEndAnnoItem(const char *name)
{
   DBG_RTF(m_textStream << "{\\comment (writeEndAnnoItem)}" << endl)
   if (name) {
      m_textStream << "\\tab ";
      writeRTFReference(name);
      m_textStream << endl;
   } else {
      m_textStream << endl;
   }
   newParagraph();
}

void RTFGenerator::startIndexKey()
{
   DBG_RTF(m_textStream << "{\\comment (startIndexKey)}" << endl)
   m_textStream << "{\\b ";
}

void RTFGenerator::endIndexKey()
{
   DBG_RTF(m_textStream << "{\\comment (endIndexKey)}" << endl)
}

void RTFGenerator::startIndexValue(bool hasBrief)
{
   DBG_RTF(m_textStream << "{\\comment (startIndexValue)}" << endl)
   m_textStream << " ";
   if (hasBrief) {
      m_textStream << "(";
   }
}

void RTFGenerator::endIndexValue(const char *name, bool hasBrief)
{
   DBG_RTF(m_textStream << "{\\comment (endIndexValue)}" << endl)
   if (hasBrief) {
      m_textStream << ")";
   }
   m_textStream << "} ";
   if (name) {
      m_textStream << "\\tab ";
      writeRTFReference(name);
      m_textStream << endl;
   } else {
      m_textStream << endl;
   }
   m_omitParagraph = false;
   newParagraph();
}

void RTFGenerator::startSubsection()
{
   //beginRTFSubSection();
   m_textStream << "\n";
   DBG_RTF(m_textStream << "{\\comment Begin SubSection}\n")
   m_textStream << rtf_Style_Reset;
   m_textStream << rtf_Style["Heading3"].reference << "\n";
}

void RTFGenerator::endSubsection()
{
   newParagraph();
   m_textStream << rtf_Style_Reset << endl;
}

void RTFGenerator::startSubsubsection()
{
   //beginRTFSubSubSection();
   m_textStream << "\n";
   DBG_RTF(m_textStream << "{\\comment Begin SubSubSection}\n")
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << rtf_Style["Heading4"].reference << "\n";
}

void RTFGenerator::endSubsubsection()
{
   newParagraph();
   m_textStream << "}" << endl;
}

void RTFGenerator::startTextLink(const QByteArray &f, const QByteArray &anchor)
{
   if (Config_getBool("RTF_HYPERLINKS")) {

      QByteArray ref;

      if (! f.isEmpty()) {
         ref += f;
      }

      if (! anchor.isEmpty()) {
         ref += '_';
         ref += anchor;
      }

      m_textStream << "{\\field {\\*\\fldinst { HYPERLINK  \\\\l \"";
      m_textStream << rtfFormatBmkStr(ref);
      m_textStream << "\" }{}";
      m_textStream << "}{\\fldrslt {\\cs37\\ul\\cf2 ";
   }
}

void RTFGenerator::endTextLink()
{
   if (Config_getBool("RTF_HYPERLINKS")) {
      m_textStream << "}}}" << endl;
   }
}

void RTFGenerator::writeObjectLink(const QByteArray &ref, const QByteArray &f, const QByteArray &anchor, const QByteArray &text)
{
   if (ref.isEmpty() && Config_getBool("RTF_HYPERLINKS")) {
      QByteArray refName;

      if (! f.isEmpty()) {
         refName += f;
      }
      if (! anchor.isEmpty()) {
         refName += '_';
         refName += anchor;
      }

      m_textStream << "{\\field {\\*\\fldinst { HYPERLINK  \\\\l \"";
      m_textStream << rtfFormatBmkStr(refName);
      m_textStream << "\" }{}";
      m_textStream << "}{\\fldrslt {\\cs37\\ul\\cf2 ";

      docify(text);

      m_textStream << "}}}" << endl;

   } else {
      startBold();
      docify(text);
      endBold();
   }
}

void RTFGenerator::startPageRef()
{
   m_textStream << " (";
   startEmphasis();
}

void RTFGenerator::endPageRef(const QByteArray &clname, const QByteArray &anchor)
{
   QByteArray ref;

   if (! clname.isEmpty()) {
      ref += clname;
   }

   if (! anchor.isEmpty()) {
      ref += '_';
      ref += anchor;
   }

   writeRTFReference(ref);
   endEmphasis();
   m_textStream << ")";
}

void RTFGenerator::writeCodeLink(const QByteArray &ref, const QByteArray &f, const QByteArray &anchor, 
                                 const QByteArray &name, const QByteArray &)
{
   if (ref.isEmpty() && Config_getBool("RTF_HYPERLINKS")) {
      QByteArray refName;

      if (! f.isEmpty()) {
         refName += f;
      }

      if (! anchor.isEmpty()) {
         refName += '_';
         refName += anchor;
      }

      m_textStream << "{\\field {\\*\\fldinst { HYPERLINK  \\\\l \"";
      m_textStream << rtfFormatBmkStr(refName);
      m_textStream << "\" }{}";
      m_textStream << "}{\\fldrslt {\\cs37\\ul\\cf2 ";

      codify(name);

      m_textStream << "}}}" << endl;

   } else {
      codify(name);
   }
}

void RTFGenerator::startTitleHead(const char *)
{
   DBG_RTF(m_textStream << "{\\comment startTitleHead}" << endl)

   //    beginRTFSection();
   m_textStream << rtf_Style_Reset << rtf_Style["Heading2"].reference << endl;
}

void RTFGenerator::endTitleHead(const char *fileName, const char *name)
{
   DBG_RTF(m_textStream << "{\\comment endTitleHead}" << endl)
   m_textStream << "\\par " << rtf_Style_Reset << endl;

   if (name) {
      // make table of contents entry
      m_textStream << "{\\tc\\tcl2 \\v ";
      docify(name);

      m_textStream << "}" << endl;

      // make an index entry
      addIndexItem(name, 0);      
      writeAnchor(fileName, 0);      
   }
}

void RTFGenerator::startTitle()
{
   DBG_RTF( << "{\\comment startTitle}" << endl)

   if (Config_getBool("COMPACT_RTF")) {
      beginRTFSection();
   } else {
      beginRTFChapter();
   }
}

void RTFGenerator::startGroupHeader(int extraIndent)
{
   DBG_RTF(m_textStream << "{\\comment startGroupHeader}" << endl)

   //newParagraph();
   m_textStream << rtf_Style_Reset;

   if (extraIndent == 2) {
      m_textStream << rtf_Style["Heading5"].reference;

   } else if (extraIndent == 1) {
      m_textStream << rtf_Style["Heading4"].reference;

   } else { // extraIndent==0
      m_textStream << rtf_Style["Heading3"].reference;
   }

   m_textStream << endl;
}

void RTFGenerator::endGroupHeader(int)
{
   DBG_RTF(m_textStream << "{\\comment endGroupHeader}" << endl)

   m_textStream << "\\par" << endl;
   m_textStream << rtf_Style_Reset << endl;
}

void RTFGenerator::startMemberDoc(const char *clname, const char *memname, const char *, const char *, bool showInline)
{
   DBG_RTF(m_textStream << "{\\comment startMemberDoc}" << endl)
   if (memname && memname[0] != '@') {
      addIndexItem(memname, clname);
      addIndexItem(clname, memname);
   }

   m_textStream << rtf_Style_Reset << rtf_Style[showInline ? "Heading5" : "Heading4"].reference;
   //styleStack.push(rtf_Style_Heading4);

   m_textStream << "{" << endl;
   //printf("RTFGenerator::startMemberDoc() `%s'\n",rtf_Style["Heading4"]->reference);
   startBold();

   m_textStream << endl;
}

void RTFGenerator::endMemberDoc(bool)
{
   DBG_RTF(m_textStream << "{\\comment endMemberDoc}" << endl)
  
   endBold();
   m_textStream << "}" << endl;
   newParagraph();
}

void RTFGenerator::startDoxyAnchor(const char *, const char *, const char *, const char *, const char *)
{
   DBG_RTF(m_textStream << "{\\comment startDoxyAnchor}" << endl)
}

void RTFGenerator::endDoxyAnchor(const char *fName, const char *anchor)
{
   QByteArray ref;

   if (fName) {
      ref += fName;
   }

   if (anchor) {
      ref += '_';
      ref += anchor;
   }

   DBG_RTF(m_textStream << "{\\comment endDoxyAnchor}" << endl)
   m_textStream << "{\\bkmkstart ";
   m_textStream << rtfFormatBmkStr(ref);
   m_textStream << "}" << endl;
   m_textStream << "{\\bkmkend ";
   m_textStream << rtfFormatBmkStr(ref);
   m_textStream << "}" << endl;
}


//void RTFGenerator::writeLatexLabel(const char *clName,const char *anchor)
//{
//  writeDoxyAnchor(0,clName,anchor,0);
//}

void RTFGenerator::addIndexItem(const char *s1, const char *s2)
{
   if (s1) {
      m_textStream << "{\\xe \\v ";
      docify(s1);

      if (s2) {
         m_textStream << "\\:";
         docify(s2);
      }

      m_textStream << "}" << endl;
   }
}

void RTFGenerator::startIndent()
{
   incrementIndentLevel();
   DBG_RTF(m_textStream << "{\\comment (startIndent) }" << endl)

   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << rtf_CList_DepthStyle() << endl;
}

void RTFGenerator::endIndent()
{
   m_textStream << "}" << endl;
   decrementIndentLevel();
}

void RTFGenerator::startDescription()
{
   DBG_RTF(m_textStream << "{\\comment (startDescription)}"    << endl)
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << rtf_DList_DepthStyle();
}

void RTFGenerator::endDescription()
{
   DBG_RTF(m_textStream << "{\\comment (endDescription)}"    << endl)
   newParagraph();
   m_textStream << "}";
}

void RTFGenerator::startDescItem()
{
   newParagraph();
   DBG_RTF(m_textStream << "{\\comment (startDescItem)}"    << endl)
   m_textStream << "{\\b ";
}

void RTFGenerator::endDescItem()
{
   DBG_RTF(m_textStream<< "{\\comment (endDescItem)}"    << endl)
   m_textStream << "}" << endl;
   newParagraph();
}

void RTFGenerator::startMemberDescription(const char *, const QByteArray &)
{
   DBG_RTF(m_textStream << "{\\comment (startMemberDescription)}"    << endl)
   m_textStream << "{" << endl;

   incrementIndentLevel();
   m_textStream << rtf_Style_Reset << rtf_CList_DepthStyle();
   startEmphasis();
}

void RTFGenerator::endMemberDescription()
{
   DBG_RTF(m_textStream << "{\\comment (endMemberDescription)}"    << endl)
   endEmphasis();
   newParagraph();
   decrementIndentLevel();

   // m_textStream << "\\par";
   m_textStream << "}" << endl;

   //m_omitParagraph = true;
}

void RTFGenerator::startDescList(SectionTypes)
{
   DBG_RTF(m_textStream << "{\\comment (startDescList)}"    << endl)
   m_textStream << "{"; // ends at endDescList
   m_textStream << "{"; // ends at endDescTitle

   startBold();
   newParagraph();
}

//void RTFGenerator::endDescTitle()
//{
//  DBG_RTF(t << "{\\comment (endDescTitle) }"    << endl)
//  endBold();
//  t << "}";
//  newParagraph();
//  incrementIndentLevel();
//  t << rtf_Style_Reset << rtf_DList_DepthStyle();
//}

void RTFGenerator::startDescForItem()
{
   DBG_RTF(m_textStream << "{\\comment (startDescForItem) }"    << endl)
}

void RTFGenerator::endDescForItem()
{
   DBG_RTF(m_textStream << "{\\comment (endDescForItem) }"    << endl)
}

//void RTFGenerator::endDescList()
//{
//  DBG_RTF(t << "{\\comment (endDescList)}"    << endl)
//  newParagraph();
//  decrementIndentLevel();
//  m_omitParagraph = true;
//  t << "}";
//}


void RTFGenerator::startSection(const char *, const char *title, SectionInfo::SectionType type)
{
   DBG_RTF(m_textStream << "{\\comment (startSection)}"    << endl)
   m_textStream << "{";
   m_textStream << rtf_Style_Reset;

   int num = 4;

   switch (type) {
      case SectionInfo::Page:
         num = 2;
         break;
      case SectionInfo::Section:
         num = 3;
         break;
      case SectionInfo::Subsection:
         num = 4;
         break;
      case SectionInfo::Subsubsection:
         num = 4;
         break;
      case SectionInfo::Paragraph:
         num = 4;
         break;
      default:
         assert(0);
         break;
   }

   QString heading;
   heading = QString("Heading%1").arg(num);

   // set style
   m_textStream << rtf_Style[heading].reference;

   // make table of contents entry
   m_textStream << "{\\tc\\tcl" << num << " \\v ";

   docify(title);
   m_textStream << "}" << endl;
}

void RTFGenerator::endSection(const char *lab, SectionInfo::SectionType)
{
   DBG_RTF(m_textStream << "{\\comment (endSection)}"    << endl)

   // make bookmark
   m_omitParagraph = false;
   newParagraph();

   writeAnchor(0, lab);
   m_textStream << "}";
}

void RTFGenerator::docify(const QByteArray &str)
{
   if (! str.isEmpty()) {
      const char *p = str.constData();
      char c;
     
      while (*p) {
         //static bool MultiByte = false;
         c = *p++;

         switch (c) {
            case '{':
               m_textStream << "\\{";
               break;

            case '}':
               m_textStream << "\\}";
               break;

            case '\\':
               m_textStream << "\\\\";
               break;

            default: {
               // see if we can insert an hyphenation hint
              
               m_textStream << c;
            }
         }
         
         m_omitParagraph = false;
      }
   }
}

void RTFGenerator::codify(const QByteArray &str)
{
   // note that RTF does not have a "verbatim", so "\n" means
   // nothing... add a "newParagraph()";
   //static char spaces[]="        ";

   if (! str.isEmpty()) {
      const char *p = str.constData();
      char c;
      int spacesToNextTabStop;

      while (*p) {
         //static bool MultiByte = false;

         c = *p++;

         switch (c) {
            case '\t':
               spacesToNextTabStop = Config_getInt("TAB_SIZE") - (col % Config_getInt("TAB_SIZE"));
               m_textStream << QString(spacesToNextTabStop, ' ');

               col += spacesToNextTabStop;
               break;

            case '\n':
               newParagraph();
               m_textStream << '\n';
               col = 0;
               break;

            case '{':
               m_textStream << "\\{";
               col++;
               break;

            case '}':
               m_textStream << "\\}";
               col++;
               break;

            case '\\':
               m_textStream << "\\\\";
               col++;
               break;

            default:
               p = writeUtf8Char(m_textStream , p - 1);
               col++;
               break;
         }
      }
   }
}

void RTFGenerator::writeChar(char c)
{
   char cs[2];
   cs[0] = c;
   cs[1] = 0;
   docify(cs);
}

void RTFGenerator::startClassDiagram()
{
   DBG_RTF(m_textStream << "{\\comment startClassDiagram }" << endl)
}

void RTFGenerator::endClassDiagram(const ClassDiagram &d, const char *fileName, const char *)
{
   newParagraph();

   // create a png file
   d.writeImage(m_textStream, dir, relPath, fileName, false);

   // display the file
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << endl;
   m_textStream << "\\par\\pard \\qc {\\field\\flddirty {\\*\\fldinst INCLUDEPICTURE \"";
   m_textStream << fileName << ".png\"";
   m_textStream << " \\\\d \\\\*MERGEFORMAT}{\\fldrslt IMAGE}}\\par" << endl;
   m_textStream << "}" << endl;
}

//void RTFGenerator::writeFormula(const char *,const char *text)
//{
//  m_textStream << text;
//}

void RTFGenerator::startMemberItem(const char *, int, const QByteArray &)
{
   DBG_RTF(m_textStream << "{\\comment startMemberItem }" << endl)
   m_textStream << rtf_Style_Reset << rtf_BList_DepthStyle() << endl; // set style to appropriate depth
}

void RTFGenerator::endMemberItem()
{
   DBG_RTF(m_textStream << "{\\comment endMemberItem }" << endl)
   newParagraph();
}

void RTFGenerator::writeAnchor(const char *fileName, const char *name)
{
   QByteArray anchor;
   if (fileName) {
      anchor += fileName;
   }
   if (fileName && name) {
      anchor += '_';
   }
   if (name) {
      anchor += name;
   }

   DBG_RTF(m_textStream << "{\\comment writeAnchor (" << anchor << ")}" << endl)
   m_textStream << "{\\bkmkstart " << rtfFormatBmkStr(anchor) << "}" << endl;
   m_textStream << "{\\bkmkend " << rtfFormatBmkStr(anchor) << "}" << endl;
}

void RTFGenerator::writeRTFReference(const char *label)
{
   m_textStream << "{\\field\\fldedit {\\*\\fldinst PAGEREF ";
   m_textStream << rtfFormatBmkStr(label);
   m_textStream << " \\\\*MERGEFORMAT}{\\fldrslt pagenum}}";
}

void RTFGenerator::startCodeFragment()
{
   DBG_RTF(m_textStream << "{\\comment (startCodeFragment) }"    << endl)
   m_textStream << "{" << endl;
   //newParagraph();
   m_textStream << rtf_Style_Reset << rtf_Code_DepthStyle();
   //styleStack.push(rtf_Style_CodeExample);
}

void RTFGenerator::endCodeFragment()
{
   //newParagraph();
   //styleStack.pop();
   //printf("RTFGenerator::endCodeFrament() top=%s\n",styleStack.top());
   //m_textStream << rtf_Style_Reset << styleStack.top() << endl;

   DBG_RTF(m_textStream << "{\\comment (endCodeFragment) }"    << endl)
   m_textStream << "}" << endl;
   m_omitParagraph = true;
}

void RTFGenerator::writeNonBreakableSpace(int)
{
   m_textStream << "\\~ ";
}

void RTFGenerator::startMemberList()
{
   m_textStream << endl;
   DBG_RTF(m_textStream << "{\\comment (startMemberList) }"    << endl)
   m_textStream << "{" << endl;

#ifdef DELETEDCODE
   if (!insideTabbing) {
      m_textStream << "\\begin{CompactItemize}" << endl;
   }
#endif
}

void RTFGenerator::endMemberList()
{
   DBG_RTF(m_textStream << "{\\comment (endMemberList) }"    << endl)
   m_textStream << "}" << endl;

#ifdef DELETEDCODE
   if (!insideTabbing) {
      m_textStream << "\\end{CompactItemize}"   << endl;
   }
#endif
}

//void RTFGenerator::startImage(const char *name,const char *,bool)
//{
//  newParagraph();
//  m_textStream << "{" << endl;
//  m_textStream << rtf_Style_Reset << endl;
//  m_textStream << "\\par\\pard \\qc {\\field\\flddirty {\\*\\fldinst INCLUDEPICTURE ";
//  m_textStream << name;
//  m_textStream << " \\\\d \\\\*MERGEFORMAT}{\\fldrslt IMAGE}}\\par" << endl;
//  m_textStream << "}" << endl;
//}
//
//void RTFGenerator::endImage(bool)
//{
//  // not yet implemented
//}
//
//void RTFGenerator::startDotFile(const char *name,bool)
//{
//  QByteArray baseName=name;
//  int i;
//  if ((i=baseName.lastIndexOf('/'))!=-1 || (i=baseName.lastIndexOf('\\'))!=-1)
//  {
//    baseName=baseName.right(baseName.length()-i-1);
//  }
//  QByteArray outDir = Config_getString("RTF_OUTPUT");
//  writeDotGraphFromFile(name,outDir,baseName,BITMAP);
//  newParagraph();
//  m_textStream << "{" << endl;
//  m_textStream << rtf_Style_Reset << endl;
//  m_textStream << "\\par\\pard \\qc {\\field\\flddirty {\\*\\fldinst INCLUDEPICTURE ";
//  m_textStream << outDir << "\\" << baseName;
//  m_textStream << " \\\\d \\\\*MERGEFORMAT}{\\fldrslt IMAGE}}\\par" << endl;
//  m_textStream << "}" << endl;
//}
//
//void RTFGenerator::endDotFile(bool)
//{
//  // not yet implemented
//}
//
void RTFGenerator::startDescTable(const char *title)
{
   DBG_RTF(m_textStream << "{\\comment (startDescTable) }"    << endl)
   startSimpleSect(EnumValues, 0, 0, title);
   startDescForItem();

   //m_textStream << "{" << endl;
   //incrementIndentLevel();
   //m_textStream << rtf_Style_Reset << rtf_CList_DepthStyle();
}

void RTFGenerator::endDescTable()
{
   //decrementIndentLevel();
   DBG_RTF(m_textStream << "{\\comment (endDescTable)}"      << endl)
   endDescForItem();
   endSimpleSect();
   //m_textStream << "}" << endl;
   //m_textStream << rtf_Style_Reset << styleStack.top();
}

void RTFGenerator::startDescTableTitle()
{
   //m_textStream << rtf_BList_DepthStyle() << endl;
   DBG_RTF(m_textStream << "{\\comment (startDescTableTitle) }"    << endl)
   startBold();
   startEmphasis();
}

void RTFGenerator::endDescTableTitle()
{
   DBG_RTF(m_textStream << "{\\comment (endDescTableTitle) }"    << endl)
   endEmphasis();
   endBold();
   m_textStream << "  ";
}

void RTFGenerator::startDescTableData()
{
   DBG_RTF(m_textStream << "{\\comment (startDescTableData) }"    << endl)
   m_omitParagraph = false;
}

void RTFGenerator::endDescTableData()
{
   DBG_RTF(m_textStream << "{\\comment (endDescTableData) }"    << endl)
   newParagraph();
   m_omitParagraph = true;
}

// a style for list formatted as a "bulleted list"

void RTFGenerator::incrementIndentLevel()
{
   m_listLevel++;
   if (m_listLevel > rtf_maxIndentLevels - 1) {
      err("Maximum indent level (%d) exceeded while generating RTF output!\n", rtf_maxIndentLevels);
      m_listLevel = rtf_maxIndentLevels - 1;
   }
}

void RTFGenerator::decrementIndentLevel()
{
   m_listLevel--;
   if (m_listLevel < 0) {
      err("Negative indent level while generating RTF output!\n");
      m_listLevel = 0;
   }
}

// a style for list formatted with "list continue" style
const char *RTFGenerator::rtf_CList_DepthStyle()
{
   QByteArray n = makeIndexName("ListContinue", m_listLevel);
   return rtf_Style[n].reference;
}

// a style for list formatted as a "latext style" table of contents
const char *RTFGenerator::rtf_LCList_DepthStyle()
{
   QByteArray n = makeIndexName("LatexTOC", m_listLevel);
   return rtf_Style[n].reference;
}

// a style for list formatted as a "bullet" style
const char *RTFGenerator::rtf_BList_DepthStyle()
{
   QByteArray n = makeIndexName("ListBullet", m_listLevel);
   return rtf_Style[n].reference;
}

// a style for list formatted as a "enumeration" style
const char *RTFGenerator::rtf_EList_DepthStyle()
{
   QByteArray n = makeIndexName("ListEnum", m_listLevel);
   return rtf_Style[n].reference;
}

const char *RTFGenerator::rtf_DList_DepthStyle()
{
   QByteArray n = makeIndexName("DescContinue", m_listLevel);
   return rtf_Style[n].reference;
}

const char *RTFGenerator::rtf_Code_DepthStyle()
{
   QByteArray n = makeIndexName("CodeExample", m_listLevel);
   return rtf_Style[n].reference;
}

void RTFGenerator::startTextBlock(bool dense)
{
   DBG_RTF(m_textStream << "{\\comment startTextBlock}" << endl)
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset;

   if (dense) { // no spacing between "paragraphs"
      m_textStream << rtf_Style["DenseText"].reference;

   } else { // some spacing
      m_textStream << rtf_Style["BodyText"].reference;
   }
}

void RTFGenerator::endTextBlock(bool /*paraBreak*/)
{
   newParagraph();
   DBG_RTF(m_textStream << "{\\comment endTextBlock}" << endl)
   m_textStream << "}" << endl;
   //m_omitParagraph = true;
}

void RTFGenerator::newParagraph()
{
   if (!m_omitParagraph) {
      DBG_RTF(m_textStream << "{\\comment (newParagraph)}"    << endl)
      m_textStream << "\\par" << endl;
   }
   m_omitParagraph = false;
}

void RTFGenerator::startParagraph()
{
   DBG_RTF(m_textStream << "{\\comment startParagraph}" << endl)
   newParagraph();
   m_textStream << "{" << endl;
}

void RTFGenerator::endParagraph()
{
   DBG_RTF(m_textStream << "{\\comment endParagraph}" << endl)
   m_textStream << "}\\par" << endl;
   m_omitParagraph = true;
}

void RTFGenerator::startMemberSubtitle()
{
   DBG_RTF(m_textStream << "{\\comment startMemberSubtitle}" << endl)
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << rtf_CList_DepthStyle() << endl;
}

void RTFGenerator::endMemberSubtitle()
{
   DBG_RTF(m_textStream << "{\\comment endMemberSubtitle}" << endl)
   newParagraph();
   m_textStream << "}" << endl;
}

bool isLeadBytes(int c)
{
   bool result;

   QByteArray codePage = theTranslator->trRTFansicp();

   if (codePage == "932") {     // cp932 (Japanese Shift-JIS)
      result = (0x81 <= c && c <= 0x9f) || (0xe0 <= c && c <= 0xfc);
   } else if (codePage == "936") { // cp936 (Simplified Chinese GBK)
      result = 0x81 <= c && c <= 0xFE;
   } else if (codePage == "949") { // cp949 (Korean)
      result = 0x81 <= c && c <= 0xFE;
   } else if (codePage == "950") { // cp950 (Traditional Chinese Big5)
      result = 0x81 <= c && c <= 0xFE;
   } else {                     // for SBCS Codepages (cp1252,1251 etc...)
      result = false;
   }

   return result;
}


// note: function is not reentrant!
static void encodeForOutput(QTextStream &t_stream, const char *s)
{
   if (s == 0) {
      return;
   }
      
   static QByteArray enc;
   QString outputEncoding = QString("CP%1").arg(theTranslator->trRTFansicp().constData());

   //
   QTextCodec *inCodec  = QTextCodec::codecForName("UTF-8");
   QTextCodec *outCodec = QTextCodec::codecForName(outputEncoding.toUtf8());
  
   if (! inCodec || ! outCodec) {
      err("Unsupported character conversion: '%s': %s\n", qPrintable(outputEncoding), strerror(errno));
      exit(1);
   }

   QString temp = inCodec->toUnicode(s);
   enc = outCodec->fromUnicode(temp);
  
   uint i;
   bool multiByte = false;

   for (i = 0; i < enc.size(); i++) {
      uchar c = (uchar)enc.at(i);

      if (c >= 0x80 || multiByte) {
         char esc[10];
         sprintf(esc, "\\'%X", c);       // escape sequence for SBCS and DBCS(1st&2nd bytes).
         t_stream << esc;

         if (!multiByte) {
            multiByte = isLeadBytes(c);  // It may be DBCS Codepages.

         } else {
            multiByte = false;           // end of Double Bytes Character.
         }

      } else {
         t_stream << (char)c;
      }
   }
}

/**
 * VERY brittle routine inline RTF's included by other RTF's.
 * it is recursive and ugly.
 */
static bool preProcessFile(QDir &d, QByteArray &infName, QTextStream &t_stream, bool bIncludeHeader = true)
{
   QFile f(infName);

   if (! f.open(QIODevice::ReadOnly)) {
      err("problems opening rtf file %s for reading\n", infName.data());
      return false;
   }

   const int maxLineLength = 10240;

   static QByteArray lineBuf;
   lineBuf.resize(maxLineLength);

   // scan until find end of header this is EXTREEEEEEEMLY brittle.  
   // It works on OUR rtf files because the first line before the body
   // ALWAYS contains "{\comment begin body}"

   do {
      if (f.readLine(lineBuf.data(), maxLineLength) == -1) {
         err("read error in %s before end of RTF header\n", infName.data());
         return false;
      }
      if (bIncludeHeader) {
         encodeForOutput(t_stream, lineBuf.data());
      }
   } while (lineBuf.indexOf("\\comment begin body") == -1);


   while (f.readLine(lineBuf.data(), maxLineLength) != -1) {
      int pos;

      if ((pos = lineBuf.indexOf("INCLUDETEXT")) != -1) {
         int startNamePos = lineBuf.indexOf('"', pos) + 1;

         int endNamePos = lineBuf.indexOf('"', startNamePos);
         QByteArray fileName = lineBuf.mid(startNamePos, endNamePos - startNamePos);

         DBG_RTF(t_stream << "{\\comment begin include " << fileName << "}" << endl)
         if (!preProcessFile(d, fileName, t_stream, false)) {
            return false;
         }

         DBG_RTF(t_stream << "{\\comment end include " << fileName << "}" << endl)

      } else { // no INCLUDETEXT on this line
         // elaborate hoopla to skip  the final "}" if we didn't include the headers

         if (! f.atEnd() || bIncludeHeader) {
            encodeForOutput(t_stream, lineBuf);

         } else { 
            // last line of included file
            // null terminate at the last '}'

            int pos = lineBuf.lastIndexOf('}');

            if (pos != -1) {
               lineBuf.resize(pos);

            } else {
               err("Last char was not a '}'\n");
            }

            encodeForOutput(t_stream, lineBuf);
         }
      }
   }

   f.close();

   // remove temporary file
   d.remove(infName);

   return true;
}

void RTFGenerator::startDotGraph()
{
   DBG_RTF(m_textStream << "{\\comment (startDotGraph)}"    << endl)
}

void RTFGenerator::endDotGraph(const DotClassGraph &g)
{
   newParagraph();

   QByteArray fn =
      g.writeGraph(m_textStream , GOF_BITMAP, EOF_Rtf, Config_getString("RTF_OUTPUT"), fileName, relPath, true, false);

   // display the file
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << endl;
   m_textStream << "\\par\\pard \\qc {\\field\\flddirty {\\*\\fldinst INCLUDEPICTURE \"";
   m_textStream << fn << "." << Config_getEnum("DOT_IMAGE_FORMAT");
   m_textStream << "\" \\\\d \\\\*MERGEFORMAT}{\\fldrslt IMAGE}}\\par" << endl;
   m_textStream << "}" << endl;
   newParagraph();

   DBG_RTF(m_textStream << "{\\comment (endDotGraph)}"    << endl)
}

void RTFGenerator::startInclDepGraph()
{
   DBG_RTF(m_textStream << "{\\comment (startInclDepGraph)}"    << endl)
}

void RTFGenerator::endInclDepGraph(const DotInclDepGraph &g)
{
   newParagraph();

   QByteArray fn = g.writeGraph(m_textStream, GOF_BITMAP, EOF_Rtf, Config_getString("RTF_OUTPUT"),
                                fileName, relPath, false);

   // display the file
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << endl;
   m_textStream << "\\par\\pard \\qc {\\field\\flddirty {\\*\\fldinst INCLUDEPICTURE \"";
   m_textStream << fn << "." << Config_getEnum("DOT_IMAGE_FORMAT");
   m_textStream << "\" \\\\d \\\\*MERGEFORMAT}{\\fldrslt IMAGE}}\\par" << endl;
   m_textStream << "}" << endl;

   DBG_RTF(m_textStream << "{\\comment (endInclDepGraph)}"    << endl)
}

void RTFGenerator::startGroupCollaboration()
{
}

void RTFGenerator::endGroupCollaboration(const DotGroupCollaboration &)
{
}

void RTFGenerator::startCallGraph()
{
   DBG_RTF(m_textStream << "{\\comment (startCallGraph)}"    << endl)
}

void RTFGenerator::endCallGraph(const DotCallGraph &g)
{
   newParagraph();

   QByteArray fn = g.writeGraph(m_textStream, GOF_BITMAP, EOF_Rtf, Config_getString("RTF_OUTPUT"),
                                fileName, relPath, false);

   // display the file
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << endl;
   m_textStream << "\\par\\pard \\qc {\\field\\flddirty {\\*\\fldinst INCLUDEPICTURE \"";
   m_textStream << fn << "." << Config_getEnum("DOT_IMAGE_FORMAT");
   m_textStream << "\" \\\\d \\\\*MERGEFORMAT}{\\fldrslt IMAGE}}\\par" << endl;
   m_textStream << "}" << endl;
   DBG_RTF(m_textStream << "{\\comment (endCallGraph)}"    << endl)
}

void RTFGenerator::startDirDepGraph()
{
   DBG_RTF(m_textStream << "{\\comment (startDirDepGraph)}"    << endl)
}

void RTFGenerator::endDirDepGraph(const DotDirDeps &g)
{
   newParagraph();

   QByteArray fn = g.writeGraph(m_textStream , GOF_BITMAP, EOF_Rtf, Config_getString("RTF_OUTPUT"),
                                fileName, relPath, false);

   // display the file
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << endl;
   m_textStream << "\\par\\pard \\qc {\\field\\flddirty {\\*\\fldinst INCLUDEPICTURE \"";
   m_textStream << fn << "." << Config_getEnum("DOT_IMAGE_FORMAT");
   m_textStream << "\" \\\\d \\\\*MERGEFORMAT}{\\fldrslt IMAGE}}\\par" << endl;
   m_textStream << "}" << endl;
   DBG_RTF(m_textStream << "{\\comment (endDirDepGraph)}"    << endl)
}

/** Tests the integrity of the result by counting brackets.
 *
 */
void testRTFOutput(const char *name)
{
   int bcount = 0;
   int line   = 1;
   char c;

   QFile f(name);

   if (f.open(QIODevice::ReadOnly)) {

      while (f.getChar(&c)) {

         if (c == '\\') { 
            // escape char
            
            if (f.getChar(&c)) {
               break;
            }

         } else if (c == '{') { // open bracket
            bcount++;

         } else if (c == '}') { // close bracket
            bcount--;

            if (bcount < 0) {
               goto err;              
            }

         } else if (c == '\n') { // newline
            line++;
         }
      }
   }

   if (bcount == 0) {
      // file is OK
      return;   
   }

err:
   err("RTF integrity test failed at line %d of %s due to a bracket mismatch.\n"
       "       Please try to create a small code example that produces this error \n"
       "       and send that to dimitri@stack.nl.\n", line, name);
}

/**
 * This is an API to a VERY brittle RTF preprocessor that combines nested
 * RTF files.  This version replaces the infile with the new file
 */
bool RTFGenerator::preProcessFileInplace(const char *path, const char *name)
{
   QDir d(path);

   // store the original directory
   if (!d.exists()) {
      err("Output dir %s does not exist!\n", path);
      return false;
   }

   QByteArray oldDir = QDir::currentPath().toUtf8();

   // go to the html output directory (i.e. path)
   QDir::setCurrent(d.absolutePath());
   QDir thisDir;

   QByteArray combinedName = (QByteArray)path + "/combined.rtf";
   QByteArray mainRTFName  = (QByteArray)path + "/" + name;

   QFile outf(combinedName);
   if (!outf.open(QIODevice::WriteOnly)) {
      err("Failed to open %s for writing!\n", combinedName.data());
      return false;
   }
   QTextStream outt(&outf);

   if (!preProcessFile(thisDir, mainRTFName, outt)) {
      // it failed, remove the temp file
      outf.close();
      thisDir.remove(combinedName);
      QDir::setCurrent(oldDir);
      return false;
   }

   // everything worked, move the files
   outf.close();
   thisDir.remove(mainRTFName);
   thisDir.rename(combinedName, mainRTFName);

   testRTFOutput(mainRTFName);

   QDir::setCurrent(oldDir);
   return true;
}

void RTFGenerator::startMemberGroupHeader(bool hasHeader)
{
   DBG_RTF(m_textStream << "{\\comment startMemberGroupHeader}" << endl)
   m_textStream << "{" << endl;
   if (hasHeader) {
      incrementIndentLevel();
   }
   m_textStream << rtf_Style_Reset << rtf_Style["GroupHeader"].reference;
}

void RTFGenerator::endMemberGroupHeader()
{
   DBG_RTF(m_textStream << "{\\comment endMemberGroupHeader}" << endl)
   newParagraph();
   m_textStream << rtf_Style_Reset << rtf_CList_DepthStyle();
}

void RTFGenerator::startMemberGroupDocs()
{
   DBG_RTF(m_textStream << "{\\comment startMemberGroupDocs}" << endl)
   startEmphasis();
}

void RTFGenerator::endMemberGroupDocs()
{
   DBG_RTF(m_textStream << "{\\comment endMemberGroupDocs}" << endl)
   endEmphasis();
   newParagraph();
}

void RTFGenerator::startMemberGroup()
{
   DBG_RTF(m_textStream << "{\\comment startMemberGroup}" << endl)
   m_textStream << rtf_Style_Reset << rtf_BList_DepthStyle() << endl;
}

void RTFGenerator::endMemberGroup(bool hasHeader)
{
   DBG_RTF(m_textStream << "{\\comment endMemberGroup}" << endl)
   if (hasHeader) {
      decrementIndentLevel();
   }
   m_textStream << "}";
}

void RTFGenerator::startSimpleSect(SectionTypes, const QByteArray &file, const char *anchor, const char *title)
{
   DBG_RTF(m_textStream << "{\\comment (startSimpleSect)}"    << endl)
   m_textStream << "{"; // ends at endDescList
   m_textStream << "{"; // ends at endDescTitle
   startBold();
   newParagraph();

   if (! file.isEmpty()) {
      writeObjectLink(0, file, anchor, title);
   } else {
      docify(title);
   }

   endBold();
   m_textStream << "}";
   newParagraph();
   incrementIndentLevel();
   m_textStream << rtf_Style_Reset << rtf_DList_DepthStyle();
}

void RTFGenerator::endSimpleSect()
{
   DBG_RTF(m_textStream << "{\\comment (endSimpleSect)}"    << endl)
   newParagraph();
   decrementIndentLevel();
   m_omitParagraph = true;
   m_textStream << "}";
}

void RTFGenerator::startParamList(ParamListTypes, const char *title)
{
   DBG_RTF(m_textStream << "{\\comment (startParamList)}"    << endl)
   m_textStream << "{"; // ends at endParamList
   m_textStream << "{"; // ends at endDescTitle
   startBold();
   newParagraph();
   docify(title);
   endBold();
   m_textStream << "}";
   newParagraph();
   incrementIndentLevel();
   m_textStream << rtf_Style_Reset << rtf_DList_DepthStyle();
}

void RTFGenerator::endParamList()
{
   DBG_RTF(m_textStream << "{\\comment (endParamList)}"    << endl)
   newParagraph();
   decrementIndentLevel();
   m_omitParagraph = true;
   m_textStream << "}";
}

void RTFGenerator::startParameterType(bool first, const QByteArray &key)
{
   DBG_RTF(m_textStream << "{\\comment (startParameterType)}"    << endl)

   if (! first && ! key.isEmpty()) {
      m_textStream << " " << key << " ";
   }
}

void RTFGenerator::endParameterType()
{
   DBG_RTF(m_textStream << "{\\comment (endParameterType)}"    << endl)
   m_textStream << " ";
}

void RTFGenerator::exceptionEntry(const QByteArray &prefix, bool closeBracket)
{
   DBG_RTF(m_textStream << "{\\comment (exceptionEntry)}"    << endl)

   if (! prefix.isEmpty()) {
      m_textStream << " " << prefix;

   } else if (closeBracket) {
      m_textStream << ")";
   }

   m_textStream << " ";
}

void RTFGenerator::writeDoc(DocNode *n, Definition *ctx, MemberDef *)
{
   RTFDocVisitor *visitor = new RTFDocVisitor(m_textStream, *this, ctx ? ctx->getDefFileExtension() : QByteArray(""));
   n->accept(visitor);
   delete visitor;
   m_omitParagraph = true;
}

void RTFGenerator::rtfwriteRuler_doubleline()
{
   DBG_RTF(m_textStream << "{\\comment (rtfwriteRuler_doubleline)}"    << endl)
   m_textStream << "{\\pard\\widctlpar\\brdrb\\brdrdb\\brdrw15\\brsp20 \\adjustright \\par}" << endl;
}

void RTFGenerator::rtfwriteRuler_emboss()
{
   DBG_RTF(m_textStream << "{\\comment (rtfwriteRuler_emboss)}"    << endl)
   m_textStream << "{\\pard\\widctlpar\\brdrb\\brdremboss\\brdrw15\\brsp20 \\adjustright \\par}" << endl;
}

void RTFGenerator::rtfwriteRuler_thick()
{
   DBG_RTF(m_textStream << "{\\comment (rtfwriteRuler_thick)}"    << endl)
   m_textStream << "{\\pard\\widctlpar\\brdrb\\brdrs\\brdrw75\\brsp20 \\adjustright \\par}" << endl;
}

void RTFGenerator::rtfwriteRuler_thin()
{
   DBG_RTF(m_textStream << "{\\comment (rtfwriteRuler_thin)}"    << endl)
   m_textStream << "{\\pard\\widctlpar\\brdrb\\brdrs\\brdrw5\\brsp20 \\adjustright \\par}" << endl;
}

#if 0
void RTFGenerator::postProcess(QByteArray &a)
{
   QByteArray enc(a.size() * 4); // worst case
   int off = 0;
   uint i;
   bool mbFlag = false;
   for (i = 0; i < a.size(); i++) {
      unsigned char c = (unsigned char)a.at(i);

      // treat characters > 0x80 as multibyte characters, except when they
      // are control characters
      if (c > 0x80 || (mbFlag && c != '\\' && c != '{' && c != '}')) {
         char s[10];
         sprintf(s, "\\'%X", c);
         qstrcpy(enc.data() + off, s);
         off += qstrlen(s);
         mbFlag = c > 0x80;
      } else {
         enc.at(off++) = c;
      }
   }
   enc.resize(off);
   a = enc;
}
#endif

void RTFGenerator::startConstraintList(const char *header)
{
   DBG_RTF(m_textStream << "{\\comment (startConstraintList)}"    << endl)
   m_textStream << "{"; // ends at endConstraintList
   m_textStream << "{";
   startBold();
   newParagraph();
   docify(header);
   endBold();
   m_textStream << "}";
   newParagraph();
   incrementIndentLevel();
   m_textStream << rtf_Style_Reset << rtf_DList_DepthStyle();
}

void RTFGenerator::startConstraintParam()
{
   DBG_RTF(m_textStream << "{\\comment (startConstraintParam)}"    << endl)
   startEmphasis();
}

void RTFGenerator::endConstraintParam()
{
   DBG_RTF(m_textStream << "{\\comment (endConstraintParam)}"    << endl)
   endEmphasis();
   m_textStream << " : ";
}

void RTFGenerator::startConstraintType()
{
   DBG_RTF(m_textStream << "{\\comment (startConstraintType)}"    << endl)
   startEmphasis();
}

void RTFGenerator::endConstraintType()
{
   DBG_RTF(m_textStream << "{\\comment (endConstraintType)}"    << endl)
   endEmphasis();
   m_textStream << " ";
}

void RTFGenerator::startConstraintDocs()
{
   DBG_RTF(m_textStream << "{\\comment (startConstraintDocs)}"    << endl)
}

void RTFGenerator::endConstraintDocs()
{
   DBG_RTF(m_textStream << "{\\comment (endConstraintDocs)}" << endl)
   newParagraph();
}

void RTFGenerator::endConstraintList()
{
   DBG_RTF(m_textStream << "{\\comment (endConstraintList)}" << endl)
   newParagraph();
   decrementIndentLevel();
   m_omitParagraph = true;
   m_textStream << "}";
}

void RTFGenerator::startIndexListItem()
{
   DBG_RTF(m_textStream << "{\\comment (startIndexListItem)}" << endl)
}

void RTFGenerator::endIndexListItem()
{
   DBG_RTF(m_textStream << "{\\comment (endIndexListItem)}" << endl)
   m_textStream << "\\par" << endl;
}

void RTFGenerator::startInlineHeader()
{
   DBG_RTF(m_textStream << "{\\comment (startInlineHeader)}" << endl)
   m_textStream << "{" << endl;
   m_textStream << rtf_Style_Reset << rtf_Style["Heading5"].reference;
   startBold();
}

void RTFGenerator::endInlineHeader()
{
   DBG_RTF(m_textStream << "{\\comment (endInlineHeader)}" << endl)
   endBold();
   m_textStream << "\\par";
   m_textStream << "}" << endl;
}

void RTFGenerator::startMemberDocSimple()
{
   DBG_RTF(m_textStream << "{\\comment (startMemberDocSimple)}" << endl)
   m_textStream << "{\\par" << endl;
   m_textStream << "{" << rtf_Style["Heading5"].reference << endl;
   m_textStream << theTranslator->trCompoundMembers() << ":\\par}" << endl;
   m_textStream << rtf_Style_Reset << rtf_DList_DepthStyle();

   m_textStream << "\\trowd \\trgaph108\\trleft426\\tblind426"
     "\\trbrdrt\\brdrs\\brdrw10\\brdrcf15 "
     "\\trbrdrl\\brdrs\\brdrw10\\brdrcf15 "
     "\\trbrdrb\\brdrs\\brdrw10\\brdrcf15 "
     "\\trbrdrr\\brdrs\\brdrw10\\brdrcf15 "
     "\\trbrdrh\\brdrs\\brdrw10\\brdrcf15 "
     "\\trbrdrv\\brdrs\\brdrw10\\brdrcf15 " << endl;

   int i, columnPos[3] = { 25, 50, 100 };

   for (i = 0; i < 3; i++) {
      m_textStream << "\\clvertalt\\clbrdrt\\brdrs\\brdrw10\\brdrcf15 "
        "\\clbrdrl\\brdrs\\brdrw10\\brdrcf15 "
        "\\clbrdrb\\brdrs\\brdrw10\\brdrcf15 "
        "\\clbrdrr \\brdrs\\brdrw10\\brdrcf15 "
        "\\cltxlrtb "
        "\\cellx" << (rtf_pageWidth * columnPos[i] / 100) << endl;
   }
   m_textStream << "\\pard \\widctlpar\\intbl\\adjustright" << endl;
}

void RTFGenerator::endMemberDocSimple()
{
   DBG_RTF(m_textStream << "{\\comment (endMemberDocSimple)}" << endl)
   m_textStream << "}" << endl;
}

void RTFGenerator::startInlineMemberType()
{
   DBG_RTF(m_textStream << "{\\comment (startInlineMemberType)}" << endl)
   m_textStream << "{\\qr ";
}

void RTFGenerator::endInlineMemberType()
{
   DBG_RTF(m_textStream << "{\\comment (endInlineMemberType)}" << endl)
   m_textStream << "\\cell }";
}

void RTFGenerator::startInlineMemberName()
{
   DBG_RTF(m_textStream << "{\\comment (startInlineMemberName)}" << endl)
   m_textStream << "{";
}

void RTFGenerator::endInlineMemberName()
{
   DBG_RTF(m_textStream << "{\\comment (endInlineMemberName)}" << endl)
   m_textStream << "\\cell }";
}

void RTFGenerator::startInlineMemberDoc()
{
   DBG_RTF(m_textStream << "{\\comment (startInlineMemberDoc)}" << endl)
   m_textStream << "{";
}

void RTFGenerator::endInlineMemberDoc()
{
   DBG_RTF(m_textStream << "{\\comment (endInlineMemberDoc)}" << endl)
   m_textStream << "\\cell }{\\row }" << endl;
}

void RTFGenerator::startLabels()
{
}

void RTFGenerator::writeLabel(const char *l, bool isLast)
{
   m_textStream << "{\\f2 [" << l << "]}";
   if (!isLast) {
      m_textStream << ", ";
   }
}

void RTFGenerator::endLabels()
{
}

